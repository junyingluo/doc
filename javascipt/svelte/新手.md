## 创建应用

npx sv create myapp

## 参考

https://www.svelte.cn/tutorial/

https://www.svelte.cn/docs

https://svelte.dev/docs

## 语法

- 变量

  ```js
  <script>
    let name = "world";
  </script>

  <h1>Hello {name}!</h1>
  ```

- 响应式

  - 响应性变量。类似于 vue 的 computed（计算属性）

    ```js
    let count = 0;
    $: doubled = count * 2;
    ```

  - 响应性语句

    ```js
    $: console.log(`the count is ${count}`);
    ```

    ```js
    $: {
      console.log(`the count is ${count}`);
      alert(`I SAID THE COUNT IS ${count}`);
    }
    ```

    ```js
    $: if (count >= 10) {
      alert(`count is dangerously high!`);
      count = 9;
    }
    ```

  * Svelte 的响应性是由赋值语句, 因此使用数组的诸如 push 和 splice 之类的方法就不会触发自动更新。

    - 添加一个多余的赋值语句

      ```js
      function addNumber() {
        numbers.push(numbers.length + 1);
        numbers = numbers;
      }
      ```

    - 一个更惯用的解决方案

      ```js
      function addNumber() {
        numbers = [...numbers, numbers.length + 1];
      }
      ```

    - 一个简单的经验法则是：被更新的变量的名称必须出现在赋值语句的左侧。例如下面这个不会触发更新

      ```js
      const foo = obj.foo;
      foo.bar = "baz";
      ```

* 绑定（元素属性能被保存到指定变量中）

  - 输入框

    ```js
    <input bind:value="{name}" />
    ```

    如果值与变量名相同，我们也可以使用简写形式

    ```
    <input bind:value />
    ```

  - 复选框 / 单选框

    ```js
    <input type="checkbox" bind:checked="{yes}" />
    ```

    组：同一组的单选框互斥的，同一组的复选框会形成一个数组

    ```js
    <script>
      let scoops = 1;
      let flavours = ["Mint choc chip"];
      let menu = ["Cookies and cream", "Mint choc chip", "Raspberry ripple"];
    </script>

    <input type="radio" bind:group="{scoops}" value="{1}" />
    <input type="radio" bind:group="{scoops}" value="{2}" />

    {#each menu as flavour}
      <input type="checkbox" bind:group="{flavours}" value="{flavour}" />
    {/each}
    ```

  - 选择框：如果含有 multiple 的属性，它将会被设置为数组而不是单值

    ```js
    <select value="{selected}" on:change="{() => answer = ''}">
      {#each questions as question}
        <option value="{question}">{question.text}</option>
      {/each}
    </select>
    ```

  - contenteditable 元素可以使用 textContent 与 innerHTML 属性的绑定

    ```html
    <div contenteditable="true" bind:innerHTML="{html}"></div>
    ```

  - 支持 each 绑定

  - video / audio

    - duration (readonly) ：视频的总时长，以秒为单位。

    - buffered (readonly) ：数组{start, end} 的对象。

    - seekable (readonly) ：同上。

    - played (readonly) ：同上。

    - seeking (readonly) ：布尔值。

    - ended (readonly) ：布尔值。

    - videoWidth (readonly)

    - videoHeight (readonly)

    - currentTime ：视频中的当前点，以秒为单位。

    - playbackRate ：播放视频的倍速， 1 为 '正常'。

    - paused ：暂停。

    - volume ：音量，0 到 1 之间的值。

  - 块级标签，支持对 clientWidth、clientHeight、offsetWidth、offsetHeight 属性进行只读绑定

    ```html
    <div bind:clientWidth="{w}" bind:clientHeight="{h}">
      <span style="font-size: {size}px">{text}</span>
    </div>
    ```

  - this 可以绑定到任何标签 (或组件) 并允许你获取对渲染标签的引用。 例如，我们对\<canvas\> 标签进行绑定，等价于 canvas = getElementsByTagName("canvas")[0]

    ```
    <canvas
      bind:this={canvas}
      width={32}
      height={32}
    ></canvas>
    ```

  - 支持对组件属性的绑定

- 逻辑

  - if-else

    ```js
    {#if x > 10}
        <p>{x} is greater than 10</p>
    {:else if 5 > x}
        <p>{x} is less than 5</p>
    {:else}
        <p>{x} is between 5 and 10</p>
    {/if}
    ```

  * 遍历数组，如下示例中，thing.id 作为 key

    ```js
    {#each things as thing (thing.id), i}
      <Thing current={thing.color}/>
    {/each}
    ```

  * await 块

    ```js
    {#await promise}
      <p>...waiting</p>
    {:then number}
      <p>The number is {number}</p>
    {:catch error}
      <p style="color: red">{error.message}</p>
    {/await}
    ```

    ```js
    {#await promise then value}
      <p>the value is {value}</p>
    {/await}
    ```

* 生命周期

  - onMount：组件首次被渲染之后

  - onDestroy：组件被销毁之后

  - beforeUpdate：组件渲染前

  - afterUpdate：组件渲染后

  - tick，类似于 vue 中 nextTick，用于等待渲染完成。如下示例，tick 将函数分割为上下两个渲染任务

    ```js
    async function handleKeydown(event) {
      if (event.which !== 9) return;

      event.preventDefault();

      const { selectionStart, selectionEnd, value } = this;
      const selection = value.slice(selectionStart, selectionEnd);

      const replacement = /[a-z]/.test(selection)
        ? selection.toUpperCase()
        : selection.toLowerCase();

      text =
        value.slice(0, selectionStart) +
        replacement +
        value.slice(selectionEnd);

      await tick();

      this.selectionStart = selectionStart;
      this.selectionEnd = selectionEnd;
    }
    ```

* Stores

  - writable

    生成

    ```js
    import { writable } from "svelte/store";
    export const count = writable(0);
    ```

    set / update

    ```js
    count.update((n) => n + 1);
    count.set(0);
    ```

    subscribe 必须在 onDestroy 中调用 unsubscribe

    ```js
    const unsubscribe = count.subscribe((value) => {
      count_value = value;
    });
    onDestroy(unsubscribe);
    ```

    $count

    ```html
    <h1>The count is {$count}</h1>
    ```

  * readable

    第一个参数 readable 可以一个是个初始值，也可以为 null 或 undefined ，第二个参数是 start 函数，该函数有个 set 回调方法，并返回一个 stop 函数。 当 stores 首次被 subscriber 时调用 start 函数，stop 则是最后当 subscriber 被 unsubscribes 时调用

    ```js
    const time = readable(new Date(), function start(set) {
      const interval = setInterval(() => {
        set(new Date());
      }, 1000);

      return function stop() {
        clearInterval(interval);
      };
    });
    ```

  * derived

    ```js
    export const elapsed = derived(time, ($time) =>
      Math.round(($time - start) / 1000)
    );
    ```

  * 自定义 stores

    只要一个对象正确的使用 subscribe ，它就是可以称之为 store

    ```js
    function createCount() {
      const { subscribe, set, update } = writable(0);

      return {
        subscribe,
        increment: () => update((n) => n + 1),
        decrement: () => update((n) => n - 1),
        reset: () => set(0),
      };
    }
    ```

  * 如果 store 可写入的(即具有 set 方法）,则可以绑定其值

- 内嵌 html

  ```js
  <script>
    let string = `this string contains some <strong>HTML!!!</strong>`;
  </script>

  <p>{@html string}</p>
  ```

* css

  ```html
  <style>
    p {
      color: purple;
      font-family: "Comic Sans MS", cursive;
      font-size: 2em;
    }
  </style>
  <p>This is a paragraph.</p>
  ```

* 事件

  - 事件处理函数：Dom 元素会传入 event 参数，this 指向 Dom 元素；组件元素，this 指向组件

    ```js
    <script>
      function handleClick() {
        alert("no more alerts");
      }
    </script>

    <button on:click|once="{handleClick}">Click me</button>
    ```

  - 修饰符

    - preventDefault ：调用 event.preventDefault() ，在运行处理程序之前调用。比如，对客户端表单处理有用。

    - stopPropagation ：调用 event.stopPropagation(), 防止事件影响到下一个元素。

    - passive ： 优化了对 touch/wheel 事件的滚动表现(Svelte 会在合适的地方自动添加滚动条)。

    - capture — 在 capture 阶段而不是 bubbling 阶段触发事件处理程序 ()

    - once ：运行一次事件处理程序后将其删除。

    - self — 仅当 event.target 是其本身时才执行

  - 事件转发

    - 示例

      Inner.svelte

      ```js
      <script>
        import { createEventDispatcher } from "svelte";

        const dispatch = createEventDispatcher();

        function sayHello() {
          dispatch("message", {
            text: "Hello!",
          });
        }
      </script>
      ```

      App.svelte

      ```js
      <Inner on:message="{handleMessage}" />
      ```

    * message 没有赋予特定的值得情况下意味着转发所有 massage 事件

      ```
      <Inner on:message/>
      ```

* 组件

  - 使用

    ```js
    <script>
      import Nested from "./Nested.svelte";
    </script>

    <Nested />
    ```

  - 属性：通过 export 指定

    ```js
    <script>
      export let answer;
    </script>

    <p>The answer is {answer}</p>
    ```

    如果你的组件含有有一个对象属性，可以利用...语法将它们 spread（传播）到一个组件上，而不用逐一指定：

    ```js
    <Info {...pkg} />
    ```

* 运动

  - tweened

  - spring

* 过渡

  - 预设过渡

    ```html
    <script>
      import { fade, fly } from "svelte/transition";
    </script>
    <p transition:fade>Fades in and out</p>
    <p transition:fly>Fades in and out</p>
    ```
