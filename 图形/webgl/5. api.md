### devicePixelRatio

高清屏的设备独立像素不等于设备物理像素，两者之比为 devicePixelRatio

因此我们需要将 width 设为 devicePixelRatio\*clientWidth，否则，渲染图片会变得模糊，因为相当于将图片放大了 devicePixelRatio 倍

```js
const canvas = document.querySelector("#canvas");
canvas.width = canvas.clientWidth * window.devicePixelRatio;
canvas.height = canvas.clientHeight * window.devicePixelRatio;

const gl = canvas.getContext("webgl");
gl.viewport(0, 0, canvas.width, canvas.height);
```

### glFlush 和 glFinish

- 与计算机 I/O 缓冲区类似，OpenGL 命令不会立即执行。所有命令都会先存储在缓冲区中，包括网络缓冲区和图形加速器本身的缓冲区，并等待缓冲区填满后再执行。例如，如果应用程序在网络上运行，将一组命令打包到一个数据包中发送，比逐个通过网络发送每个命令要高效得多。

- glFlush 函数会清空所有缓冲区中的命令，并强制所有待执行的命令立即执行，无需等待缓冲区满。因此，glFlush 保证了在此之前发出的所有 OpenGL 命令在调用 glFlush 后的有限时间内都能完成执行。此外，glFlush 不会等待之前的命令执行完毕，而是会立即返回到你的程序。所以，即使之前发出的命令尚未完成，你也可以继续发送更多命令。

- glFinish 函数会像 glFlush 函数一样刷新缓冲区并强制命令开始执行，但 glFinish 会阻塞其他 OpenGL 命令，并等待所有命令执行完毕。因此，glFinish 不会返回到程序，直到所有先前调用的命令都执行完毕。它可以用于同步任务或测量特定 OpenGL 命令的精确执行时间。
