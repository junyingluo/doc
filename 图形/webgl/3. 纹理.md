### 纹理

- 纹理其实是一块 buffer，通常用于“图片加载”或“后端存储”

### 图片加载

- vertexShader

  ```c
  attribute vec4 a_Position;
  attribute vec2 a_uv;
  varying vec2 v_uv;

  void main(){
    gl_Position = a_Position;
    v_uv = a_uv;
  }
  ```

- fragmentShader
  - texture2D 来取色

  ```c
  precision mediump float;
  uniform sampler2D u_Sampler;
  varying vec2 v_uv;

  void main(){
    gl_FragColor = texture2D(u_Sampler, v_uv);
  }
  ```

- 数据加载

  ```js
  // 使用 0 号纹理索引
  gl.activeTexture(gl.TEXTURE0);
  const texture = gl.createTexture();
  // 绑定到 0 号纹理索引
  gl.bindTexture(gl.TEXTURE_2D, texture);
  // 将着色器中 u_Sampler 设置为 0 号纹理索引
  const u_Sampler = gl.getUniformLocation(gl.program, "u_Sampler");
  gl.uniform1i(u_Sampler, 0);

  const image = new Image();
  image.src = "./images/erha.jpg";
  image.onload = function () {
    const gl = this._gl;
    gl.bindTexture(gl.TEXTURE_2D, this._texture);
    // 翻转 Y 轴，匹配 WebGL 纹理坐标
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
    // 设置采样规则
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    // 将图片数据传到 GPU 纹理
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
  };
  ```

* pixelStorei
  - 普通图片（PNG/JPG）y 轴向下，WebGL 纹理 y 轴向上，因此传输数据时，需要颠倒 y 轴

- texParameteri

- texImage2D
  - 设置纹理类型，并上传图片数据

### 后端存储
