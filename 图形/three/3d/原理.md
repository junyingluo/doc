### 目标：尽可能最大化展示所有三维图形在一个屏幕

```js
const data = [
  {
    center: { x: -883.58, y: -627.63, z: -39.62 },
    size: { x: 21.94, y: 8.15, z: 2.57 },
  },
  {
    center: { x: -910.43, y: -583.21, z: -47.64 },
    size: { x: 6.6, y: 0.73, z: 0.26 },
  },
];
```

### 将所有点添加到 scene 中

```js
data.forEach((o) => {
  scene.add(createBox(o.size, o.center));
});
```

### 计算轴对齐包围盒（包含所有点最小长方体）

```js
function collectVertices(obstacles: any[]): THREE.Vector3[] {
  const pts: THREE.Vector3[] = [];

  obstacles.forEach(({ center, size }) => {
    const hx = size.x / 2;
    const hy = size.y / 2;
    const hz = size.z / 2;
    pts.push(new THREE.Vector3(center.x + hx, center.y + hy, center.z + hz));
    pts.push(new THREE.Vector3(center.x - hx, center.y - hy, center.z - hz));
  });

  return pts;
}

const points = collectVertices(obstacles);

const box = new THREE.Box3().setFromPoints(points);
```

### 设置相机位置

```js
class AsymmetricPerspectiveCamera extends THREE.Camera {
  constructor() {
    super();
    this.projectionMatrix = new THREE.Matrix4();
  }

  updateProjectionMatrix() {
    this.projectionMatrix.makePerspective(
      this.left,
      this.right,
      this.top,
      this.bottom,
      this.near,
      this.far,
    );
  }
}

const center = box.getCenter(new THREE.Vector3());
const size = box.getSize(new THREE.Vector3());

camera = new AsymmetricPerspectiveCamera();

// 相机放在正前方
const distance = size.length();
camera.position.set(center.x, center.y, center.z + distance);
camera.lookAt(center);
camera.updateMatrixWorld(true);
```

### 求相机视角下的坐标

```js
const view = camera.matrixWorldInverse.clone();
const camPts = points.map((p) => p.clone().applyMatrix4(view));

// near / far
let near = Infinity;
let far = 0;

camPts.forEach((p) => {
  if (p.z < 0) {
    near = Math.min(near, -p.z);
    far = Math.max(far, -p.z);
  }
});

near *= 0.9;
far *= 1.1;

let left = Infinity;
let right = -Infinity;
let bottom = Infinity;
let top = -Infinity;

camPts.forEach((p) => {
  if (p.z < 0) {
    const x = (p.x * near) / -p.z;
    const y = (p.y * near) / -p.z;

    left = Math.min(left, x);
    right = Math.max(right, x);
    bottom = Math.min(bottom, y);
    top = Math.max(top, y);
  }
});
```

### 设置相机的投影矩阵

```js
camera.left = left;
camera.right = right;
camera.bottom = bottom;
camera.top = top;
camera.near = near;
camera.far = far;

camera.updateProjectionMatrix();
```
