### 坐标系

- 右手系：右手拇指指向 X 轴正方向，食指指向 Y 轴正方向，自然弯曲的中指所指方向，就是 Z 轴正方向
  - 地理坐标系、世界坐标系
- 左手系：左手手拇指指向 X 轴正方向，食指指向 Y 轴正方向，自然弯曲的中指所指方向，就是 Z 轴正方向
  - Opengl 设备坐标系
- 右手系和左手系，x 和 y 轴方向相同，z 轴方向相反

### 经纬度

- 经度（longitude）东西向，向东为正，[-180°, +180°]
  - 本初子午线为 0 度

* 纬度（latitude）南北向，北向为正，[-90°, +90°]
  - 纬度是指过椭球面上某点作法线，该点法线与赤道平面的线面角

### WGS84 标准地球

- x 轴：赤道东向半轴；
- y 轴：赤道北向半轴；
- z 轴：极地方向（南北极）半轴。

- WGS84 模型，可以理解为，xz 平面上一个椭圆，绕 z 轴旋转形成椭球，垂直于 z 轴的切面是一个圆，因此赤道东向半轴和北向半轴是相同的

* 赤道东向半径，6378137.0
* 赤道北向半径，6378137.0
* 地球极半径，6356752.3142451793

```js
Ellipsoid.WGS84 = Object.freeze(
  new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793),
);
```

### 世界坐标系（ECEF）

 <img src="assets/1. 坐标系/2.avif" width="30%" height="30%" />

- 原点：地球质心
- X 轴：指向本初子午线与赤道的交点；
- Y 轴：在赤道平面内，垂直于 X 轴，指向 90°E 经度方向（正东）；
- Z 轴：指向地球北极

### 地理坐标系（ENU）

![alt text](<assets/1. 坐标系/1.avif>)

- 又称站立坐标系
  - 原点：观察者位置
  * X 轴：指向东（East）→ 这是 Cesium 定义的 “前向轴（forwardAxis）”；
  * Y 轴：指向北（North）；
  * Z 轴：指向天（Up，垂直地球表面向上）。

* HeadingPitchRange
  - Heading（航向角）：水平朝向
  * Pitch（俯仰角）：垂直仰俯
  - Range 相机与目标的直线距离

### cartographicToCartesian

- 根据经度、纬度、高度求 ECEF 坐标点

```js
ellipsoid._radii = new Cartesian3(x, y, z);
ellipsoid._radiiSquared = new Cartesian3(x * x, y * y, z * z);

Ellipsoid.prototype.cartographicToCartesian = function (cartographic, result) {
  const n = cartographicToCartesianNormal;
  const k = cartographicToCartesianK;
  // 求法向量 n
  this.geodeticSurfaceNormalCartographic(cartographic, n);
  Cartesian3.multiplyComponents(this._radiiSquared, n, k);
  const gamma = Math.sqrt(Cartesian3.dot(n, k));
  // 求椭球表面点的坐标 k
  Cartesian3.divideByScalar(k, gamma, k);
  // 将法向量按高度比例延长
  Cartesian3.multiplyByScalar(n, cartographic.height, n);

  if (!defined(result)) {
    result = new Cartesian3();
  }
  // k + n 即为所求结果
  return Cartesian3.add(k, n, result);
};
```

### eastNorthUpToFixedFrame

- eastNorthUpToFixedFrame 以 origin 为原点，ellipsoid 为地球模型，构造 ENU 坐标系

* $M = \begin {bmatrix}
  east_x & north_x & up_x & origin_x \\
  east_y & north_y & up_y & origin_y \\
  east_z & north_z & up_z & origin_z \\
  0 & 0 & 0 & 1
  \end {bmatrix}$

```js
function eastNorthUpToFixedFrame(origin, ellipsoid, result) {
  let result = new Matrix4();

  ellipsoid = ellipsoid ?? Ellipsoid.default;
  ellipsoid.geodeticSurfaceNormal(origin, scratchCalculateCartesian.up);

  const up = scratchCalculateCartesian.up;
  const east = scratchCalculateCartesian.east;
  east.x = -origin.y;
  east.y = origin.x;
  east.z = 0.0;
  Cartesian3.normalize(east, scratchCalculateCartesian.east);
  Cartesian3.cross(up, east, scratchCalculateCartesian.north);

  scratchFirstCartesian = scratchCalculateCartesian.east;
  scratchSecondCartesian = scratchCalculateCartesian.north;
  scratchThirdCartesian = scratchCalculateCartesian.up;

  result[0] = scratchFirstCartesian.x;
  result[1] = scratchFirstCartesian.y;
  result[2] = scratchFirstCartesian.z;
  result[3] = 0.0;
  result[4] = scratchSecondCartesian.x;
  result[5] = scratchSecondCartesian.y;
  result[6] = scratchSecondCartesian.z;
  result[7] = 0.0;
  result[8] = scratchThirdCartesian.x;
  result[9] = scratchThirdCartesian.y;
  result[10] = scratchThirdCartesian.z;
  result[11] = 0.0;
  result[12] = origin.x;
  result[13] = origin.y;
  result[14] = origin.z;
  result[15] = 1.0;
  return result;
}
```

### transform

- position 变换为 transform 指定的坐标系，positionWC 不变
  - 第一次 updateMembers
    - positionWC = transform \* position
  - 第二次 updateMembers
    - position = invTransform \* position
    * positionWC = transform \* invTransform \* position = position

```js
Camera.prototype._setTransform = function (transform) {
  const position = Cartesian3.clone(this.positionWC, setTransformPosition);
  const up = Cartesian3.clone(this.upWC, setTransformUp);
  const direction = Cartesian3.clone(this.directionWC, setTransformDirection);

  Matrix4.clone(transform, this._transform);
  this._transformChanged = true;
  updateMembers(this);
  const inverse = this._actualInvTransform;

  Matrix4.multiplyByPoint(inverse, position, this.position);
  Matrix4.multiplyByPointAsVector(inverse, direction, this.direction);
  Matrix4.multiplyByPointAsVector(inverse, up, this.up);
  Cartesian3.cross(this.direction, this.up, this.right);

  updateMembers(this);
};
```

### updateMembers

- \_invTransform = \_transform<sup>-1</sup>
- \_actualTransform = \_transform
- \_actualInvTransform = \_actualTransform<sup>-1</sup>
- \_position = position
- \_positionWC = \_transform \* \_position
- \_direction = direction
- \_directionWC = \_actualTransform \* \_direction
- \_up = up
- \_upWC = \_actualTransform \* \_up
- \_right = right
- \_rightWC = \_actualTransform \* \_right

* \_viewMatrix = (\_position,\_direction,\_up,\_right) \* \_actualInvTransform
* \_invViewMatrix = \_viewMatrix<sup>-1</sup>
