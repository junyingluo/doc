```js
tileset = await Cesium.Cesium3DTileset.fromUrl("./Production_3.json");
```

```js
Cesium3DTileset.fromUrl = async function (url, options) {
  options = options ?? Frozen.EMPTY_OBJECT;

  // Resource { url: "./Production_3.json" }
  const resource = Resource.createIfNeeded(url);
  // basePath = ./
  let basePath = resource.getBaseUri(true);

  // tilesetJson = { "asset": {...}, ... }，即 Production_3.json 内容
  const tilesetJson = await Cesium3DTileset.loadJson(resource);

  const tileset = new Cesium3DTileset(options);
  tileset._resource = resource;
  tileset._url = resource.url;
  tileset._basePath = basePath;
  // Set these before loading the tileset since _geometricError
  // and _scaledGeometricError get accessed during tile creation
  tileset._geometricError = tilesetJson.geometricError;
  tileset._scaledGeometricError = tilesetJson.geometricError;

  const asset = tilesetJson.asset;
  tileset._asset = asset;
  tileset._extras = tilesetJson.extras;

  // tileset._credits = []
  createCredits(tileset);

  // var Axis = {X:0,Y:1,Z:2};
  // gltfUpAxis = 1
  const gltfUpAxis = defined(tilesetJson.asset.gltfUpAxis)
    ? Axis.fromName(tilesetJson.asset.gltfUpAxis)
    : Axis.Y;
  // modelUpAxis = 1
  const modelUpAxis = options.modelUpAxis ?? gltfUpAxis;
  // modelForwardAxis = 0 默认朝东
  const modelForwardAxis = options.modelForwardAxis ?? Axis.X;

  tileset._properties = tilesetJson.properties;
  tileset._extensionsUsed = tilesetJson.extensionsUsed;
  tileset._extensions = tilesetJson.extensions;
  tileset._modelUpAxis = modelUpAxis;
  tileset._modelForwardAxis = modelForwardAxis;

  tileset._root = tileset.loadTileset(resource, tilesetJson);

  // Save the original, untransformed bounding volume position so we can apply
  // the tile transform and model matrix at run time
  const boundingVolume = tileset._root.createBoundingVolume(
    tilesetJson.root.boundingVolume,
    Matrix4.IDENTITY,
  );
  const clippingPlanesOrigin = boundingVolume.boundingSphere.center;
  // If this origin is above the surface of the earth
  // we want to apply an ENU orientation as our best guess of orientation.
  // Otherwise, we assume it gets its position/orientation completely from the
  // root tile transform and the tileset's model matrix
  const originCartographic =
    tileset._ellipsoid.cartesianToCartographic(clippingPlanesOrigin);
  if (
    defined(originCartographic) &&
    originCartographic.height >
      ApproximateTerrainHeights._defaultMinTerrainHeight
  ) {
    tileset._initialClippingPlanesOriginMatrix =
      Transforms.eastNorthUpToFixedFrame(clippingPlanesOrigin);
  }
  tileset._clippingPlanesOriginMatrix = Matrix4.clone(
    tileset._initialClippingPlanesOriginMatrix,
  );

  return tileset;
};
```

```js
Cesium3DTileset.prototype.loadTileset = function (
  resource,
  tilesetJson,
  parentTile,
) {
  const asset = tilesetJson.asset;
  const statistics = this._statistics;

  // A tileset JSON file referenced from a tile may exist in a different directory than the root tileset.
  // Get the basePath relative to the external tileset.
  const rootTile = new Cesium3DTile(
    this,
    resource,
    tilesetJson.root,
    parentTile,
  );

  // If there is a parentTile, add the root of the currently loading tileset
  // to parentTile's children, and update its _depth.
  if (defined(parentTile)) {
    parentTile.children.push(rootTile);
    rootTile._depth = parentTile._depth + 1;
  }

  const stack = [];
  stack.push(rootTile);

  while (stack.length > 0) {
    const tile = stack.pop();
    ++statistics.numberOfTilesTotal;
    this._allTilesAdditive =
      this._allTilesAdditive && tile.refine === Cesium3DTileRefine.ADD;
    const children = tile._header.children;
    if (defined(children)) {
      for (let i = 0; i < children.length; ++i) {
        const childHeader = children[i];
        const childTile = new Cesium3DTile(this, resource, childHeader, tile);
        tile.children.push(childTile);
        childTile._depth = tile._depth + 1;
        stack.push(childTile);
      }
    }

    if (this._cullWithChildrenBounds) {
      Cesium3DTileOptimizations.checkChildrenWithinParent(tile);
    }
  }

  return rootTile;
};
```

```js
function Cesium3DTile(tileset, baseResource, header, parent) {
  this._tileset = tileset;
  this._header = header;

  const hasContentsArray = defined(header.contents);
  const hasMultipleContents =
    (hasContentsArray && header.contents.length > 1) ||
    hasExtension(header, "3DTILES_multiple_contents");

  // In the 1.0 schema, content is stored in tile.content instead of tile.contents
  const contentHeader =
    hasContentsArray && !hasMultipleContents
      ? header.contents[0]
      : header.content;

  this._contentHeader = contentHeader;

  // 自身变换，默认则为单位矩阵
  this.transform = defined(header.transform)
    ? Matrix4.unpack(header.transform)
    : Matrix4.clone(Matrix4.IDENTITY);

  // 父变换，默认为单位矩阵
  const parentTransform = defined(parent)
    ? parent.computedTransform
    : tileset.modelMatrix;

  // 最终变换，默认为单位矩阵
  const computedTransform = Matrix4.multiply(
    parentTransform,
    this.transform,
    new Matrix4(),
  );

  // 父初始变换，默认为单位矩阵
  const parentInitialTransform = defined(parent)
    ? parent._initialTransform
    : Matrix4.IDENTITY;

  // 最终初始变换，默认为单位矩阵
  this._initialTransform = Matrix4.multiply(
    parentInitialTransform,
    this.transform,
    new Matrix4(),
  );

  this.computedTransform = computedTransform;

  this._verticalExaggeration = 1.0;
  this._verticalExaggerationRelativeHeight = 0.0;

  this._boundingVolume = this.createBoundingVolume(
    header.boundingVolume,
    computedTransform,
  );
  this._boundingVolume2D = undefined;

  this.geometricError = header.geometricError;
  this._geometricError = header.geometricError;

  this.updateGeometricErrorScale();

  let refine;
  if (defined(header.refine)) {
    refine =
      header.refine.toUpperCase() === "REPLACE"
        ? Cesium3DTileRefine.REPLACE
        : Cesium3DTileRefine.ADD;
  } else if (defined(parent)) {
    // Inherit from parent tile if omitted.
    refine = parent.refine;
  } else {
    refine = Cesium3DTileRefine.REPLACE;
  }

  this.refine = refine;

  this.children = [];

  this.parent = parent;

  let content;
  let hasEmptyContent = false;
  let contentState;
  let contentResource;
  let serverKey;

  baseResource = Resource.createIfNeeded(baseResource);

  if (defined(contentHeader)) {
    let contentHeaderUri = contentHeader.uri;
    contentState = Cesium3DTileContentState.UNLOADED;
    contentResource = baseResource.getDerivedResource({
      url: contentHeaderUri,
    });
    serverKey = RequestScheduler.getServerKey(
      contentResource.getUrlComponent(),
    );
  } else {
    content = new Empty3DTileContent(tileset, this);
    hasEmptyContent = true;
    contentState = Cesium3DTileContentState.READY;
  }

  this._content = content;
  this._contentResource = contentResource;
  this._contentState = contentState;
  this._expiredContent = undefined;
}
```

```js
Cesium3DTile.prototype.createBoundingVolume = function (
  boundingVolumeHeader,
  transform,
  result,
) {
  const { box, region, sphere } = boundingVolumeHeader;
  if (defined(sphere)) {
    const tileBoundingSphere = createSphere(sphere, transform, result);
    return tileBoundingSphere;
  }
  throw new RuntimeError(
    "boundingVolume must contain a sphere, region, or box",
  );
};
function createSphere(sphere, transform, result) {
  let center = Cartesian3.fromElements(
    sphere[0],
    sphere[1],
    sphere[2],
    scratchCenter,
  );
  let radius = sphere[3];

  // Find the transformed center and radius
  center = Matrix4.multiplyByPoint(transform, center, center);
  const scale = Matrix4.getScale(transform, scratchScale);
  const uniformScale = Cartesian3.maximumComponent(scale);
  radius *= uniformScale;

  if (defined(result)) {
    result.update(center, radius);
    return result;
  }
  return new TileBoundingSphere(center, radius);
}
```

```js
function zoomToOrFly(that, zoomTarget, options, isFlight) {
  //>>includeStart('debug', pragmas.debug);
  if (!defined(zoomTarget)) {
    throw new DeveloperError("zoomTarget is required.");
  }
  //>>includeEnd('debug');

  cancelZoom(that);

  //We can't actually perform the zoom until all visualization is ready and
  //bounding spheres have been computed.  Therefore we create and return
  //a deferred which will be resolved as part of the post-render step in the
  //frame that actually performs the zoom.
  const zoomPromise = new Promise((resolve) => {
    that._completeZoom = function (value) {
      resolve(value);
    };
  });
  that._zoomPromise = zoomPromise;
  that._zoomIsFlight = isFlight;
  that._zoomOptions = options;

  Promise.resolve(zoomTarget).then(function (zoomTarget) {
    that._zoomTarget = zoomTarget;
  });

  that.scene.requestRender();
  return zoomPromise;
}
```
