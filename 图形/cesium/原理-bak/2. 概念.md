### 地理坐标系：ENU（东 - 北 - 天）

- Cesium 在地球表面的局部坐标系默认是 ENU 坐标系（右手系）：
- X 轴：指向东（East）→ 这是 Cesium 定义的 “前向轴（forwardAxis）”；
- Y 轴：指向北（North）；
- Z 轴：指向天（Up，垂直地球表面向上）。

### WGS84 标准地球

- x 轴：赤道东向半轴；
- y 轴：赤道北向半轴；
- z 轴：极地方向（南北极）半轴。

- WGS84 模型，可以理解为，xz平面上一个椭圆，绕z轴旋转形成椭球，垂直于z轴的切面是一个圆，因此赤道东向半轴和北向半轴是相同的

* 赤道东向半径，6378137.0
* 赤道北向半径，6378137.0
* 地球极半径，6356752.3142451793

```js
Ellipsoid.WGS84 = Object.freeze(
  new Ellipsoid(6378137.0, 6378137.0, 6356752.3142451793),
);
```

### eastNorthUpToFixedFrame

tileset.\_initialClippingPlanesOriginMatrix = Transforms.eastNorthUpToFixedFrame(clippingPlanesOrigin);

```js
const vectorProductLocalFrame = {
  up: {
    south: "east",
    north: "west",
    west: "south",
    east: "north",
  },
  down: {
    south: "west",
    north: "east",
    west: "north",
    east: "south",
  },
  south: {
    up: "west",
    down: "east",
    west: "down",
    east: "up",
  },
  north: {
    up: "east",
    down: "west",
    west: "up",
    east: "down",
  },
  west: {
    up: "north",
    down: "south",
    north: "down",
    south: "up",
  },
  east: {
    up: "south",
    down: "north",
    north: "up",
    south: "down",
  },
};
Transforms.eastNorthUpToFixedFrame = Transforms.localFrameToFixedFrameGenerator(
  "east",
  "north",
);
Transforms.localFrameToFixedFrameGenerator = function (firstAxis, secondAxis) {
  const thirdAxis = vectorProductLocalFrame[firstAxis][secondAxis];

  return function (origin, ellipsoid, result) {
    let result = new Matrix4();

    ellipsoid = ellipsoid ?? Ellipsoid.default;
    ellipsoid.geodeticSurfaceNormal(origin, scratchCalculateCartesian.up);

    const up = scratchCalculateCartesian.up;
    const east = scratchCalculateCartesian.east;
    east.x = -origin.y;
    east.y = origin.x;
    east.z = 0.0;
    Cartesian3.normalize(east, scratchCalculateCartesian.east);
    Cartesian3.cross(up, east, scratchCalculateCartesian.north);

    Cartesian3.multiplyByScalar(
      scratchCalculateCartesian.up,
      -1,
      scratchCalculateCartesian.down,
    );
    Cartesian3.multiplyByScalar(
      scratchCalculateCartesian.east,
      -1,
      scratchCalculateCartesian.west,
    );
    Cartesian3.multiplyByScalar(
      scratchCalculateCartesian.north,
      -1,
      scratchCalculateCartesian.south,
    );

    scratchFirstCartesian = scratchCalculateCartesian[firstAxis];
    scratchSecondCartesian = scratchCalculateCartesian[secondAxis];
    scratchThirdCartesian = scratchCalculateCartesian[thirdAxis];

    result[0] = scratchFirstCartesian.x;
    result[1] = scratchFirstCartesian.y;
    result[2] = scratchFirstCartesian.z;
    result[3] = 0.0;
    result[4] = scratchSecondCartesian.x;
    result[5] = scratchSecondCartesian.y;
    result[6] = scratchSecondCartesian.z;
    result[7] = 0.0;
    result[8] = scratchThirdCartesian.x;
    result[9] = scratchThirdCartesian.y;
    result[10] = scratchThirdCartesian.z;
    result[11] = 0.0;
    result[12] = origin.x;
    result[13] = origin.y;
    result[14] = origin.z;
    result[15] = 1.0;
    return result;
  };
};
```
