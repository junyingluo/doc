### spin3D

- startPosition 鼠标开始点
- movement 鼠标运动量

```js
function spin3D(controller, startPosition, movement) {
  const scene = controller._scene;
  const camera = scene.camera;
  const cameraUnderground = controller._cameraUnderground;
  let ellipsoid = controller._ellipsoid;

  if (!Matrix4.equals(camera.transform, Matrix4.IDENTITY)) {
    rotate3D(controller, startPosition, movement);
    return;
  }

  let magnitude;
  let radii;

  const up = ellipsoid.geodeticSurfaceNormal(camera.position, scratchLookUp);

  if (Cartesian2.equals(startPosition, controller._rotateMousePosition)) {
    ......
    return;
  }
  controller._looking = false;
  controller._rotating = false;
  controller._strafing = false;

  const height = ellipsoid.cartesianToCartographic(
    camera.positionWC,
    scratchCartographic,
  ).height;
  const globe = controller._globe;

  if (defined(globe) && height < controller._minimumPickingTerrainHeight) {
    ......
  } else if (
    defined(
      camera.pickEllipsoid(
        movement.startPosition,
        controller._ellipsoid,
        spin3DPick,
      ),
    )
  ) {
    pan3D(controller, startPosition, movement, controller._ellipsoid);
    Cartesian3.clone(spin3DPick, controller._rotateStartPosition);
  } else if (height > controller._minimumTrackBallHeight) {
    controller._rotating = true;
    rotate3D(controller, startPosition, movement);
  } else {
    controller._looking = true;
    look3D(controller, startPosition, movement, up);
  }

  Cartesian2.clone(startPosition, controller._rotateMousePosition);
}
```

### pan3D

 <img src="assets/1. 平移/1.png" width="30%" height="30%" />

```js
function pan3D(controller, startPosition, movement, ellipsoid) {
  const scene = controller._scene;
  const camera = scene.camera;

  const startMousePosition = Cartesian2.clone(
    movement.startPosition,
    pan3DStartMousePosition,
  );
  const endMousePosition = Cartesian2.clone(
    movement.endPosition,
    pan3DEndMousePosition,
  );
  const height = ellipsoid.cartesianToCartographic(
    camera.positionWC,
    scratchCartographic,
  ).height;

  let p0, p1;

  if (
    !movement.inertiaEnabled &&
    height < controller._minimumPickingTerrainHeight
  ) {
    ......
  }

  if (!defined(p0) || !defined(p1)) {
    p0 = camera.pickEllipsoid(startMousePosition, ellipsoid, pan3DP0);
    p1 = camera.pickEllipsoid(endMousePosition, ellipsoid, pan3DP1);
  }

  if (!defined(p0) || !defined(p1)) {
    controller._rotating = true;
    rotate3D(controller, startPosition, movement);
    return;
  }

  p0 = camera.worldToCameraCoordinates(p0, p0);
  p1 = camera.worldToCameraCoordinates(p1, p1);

  if (!defined(camera.constrainedAxis)) {
    ......
  } else {
    const basis0 = camera.constrainedAxis;
    const basis1 = Cartesian3.mostOrthogonalAxis(basis0, pan3DTemp0);
    Cartesian3.cross(basis1, basis0, basis1);
    Cartesian3.normalize(basis1, basis1);
    const basis2 = Cartesian3.cross(basis0, basis1, pan3DTemp1);

    const startRho = Cartesian3.magnitude(p0);
    const startDot = Cartesian3.dot(basis0, p0);
    const startTheta = Math.acos(startDot / startRho);
    const startRej = Cartesian3.multiplyByScalar(basis0, startDot, pan3DTemp2);
    Cartesian3.subtract(p0, startRej, startRej);
    Cartesian3.normalize(startRej, startRej);

    const endRho = Cartesian3.magnitude(p1);
    const endDot = Cartesian3.dot(basis0, p1);
    const endTheta = Math.acos(endDot / endRho);
    const endRej = Cartesian3.multiplyByScalar(basis0, endDot, pan3DTemp3);
    Cartesian3.subtract(p1, endRej, endRej);
    Cartesian3.normalize(endRej, endRej);

    let startPhi = Math.acos(Cartesian3.dot(startRej, basis1));
    if (Cartesian3.dot(startRej, basis2) < 0) {
      startPhi = CesiumMath.TWO_PI - startPhi;
    }

    let endPhi = Math.acos(Cartesian3.dot(endRej, basis1));
    if (Cartesian3.dot(endRej, basis2) < 0) {
      endPhi = CesiumMath.TWO_PI - endPhi;
    }

    const deltaPhi = startPhi - endPhi;

    let east;
    if (
      Cartesian3.equalsEpsilon(basis0, camera.position, CesiumMath.EPSILON2)
    ) {
      east = camera.right;
    } else {
      east = Cartesian3.cross(basis0, camera.position, pan3DTemp0);
    }

    const planeNormal = Cartesian3.cross(basis0, east, pan3DTemp0);
    const side0 = Cartesian3.dot(
      planeNormal,
      Cartesian3.subtract(p0, basis0, pan3DTemp1),
    );
    const side1 = Cartesian3.dot(
      planeNormal,
      Cartesian3.subtract(p1, basis0, pan3DTemp1),
    );

    let deltaTheta;
    if (side0 > 0 && side1 > 0) {
      deltaTheta = endTheta - startTheta;
    } else if (side0 > 0 && side1 <= 0) {
      if (Cartesian3.dot(camera.position, basis0) > 0) {
        deltaTheta = -startTheta - endTheta;
      } else {
        deltaTheta = startTheta + endTheta;
      }
    } else {
      deltaTheta = startTheta - endTheta;
    }

    camera.rotateRight(deltaPhi);
    camera.rotateUp(deltaTheta);
  }
}
```

```
Camera.prototype.rotateRight = function (angle) {
  angle = angle ?? this.defaultRotateAmount;
  rotateHorizontal(this, -angle);
};
function rotateHorizontal(camera, angle) {
  if (defined(camera.constrainedAxis)) {
    camera.rotate(camera.constrainedAxis, angle);
  } else {
    camera.rotate(camera.up, angle);
  }
}
Camera.prototype.rotate = function (axis, angle) {
  //>>includeStart('debug', pragmas.debug);
  if (!defined(axis)) {
    throw new DeveloperError("axis is required.");
  }
  //>>includeEnd('debug');

  const turnAngle = angle ?? this.defaultRotateAmount;
  const quaternion = Quaternion.fromAxisAngle(
    axis,
    -turnAngle,
    rotateScratchQuaternion,
  );
  const rotation = Matrix3.fromQuaternion(quaternion, rotateScratchMatrix);
  Matrix3.multiplyByVector(rotation, this.position, this.position);
  Matrix3.multiplyByVector(rotation, this.direction, this.direction);
  Matrix3.multiplyByVector(rotation, this.up, this.up);
  Cartesian3.cross(this.direction, this.up, this.right);
  Cartesian3.cross(this.right, this.direction, this.up);

  this._adjustOrthographicFrustum(false);
};
```

```js
Camera.prototype.rotateUp = function (angle) {
  angle = angle ?? this.defaultRotateAmount;
  rotateVertical(this, -angle);
};
function rotateVertical(camera, angle) {
  const position = camera.position;
  const constrainedAxis = Cartesian3.normalize(
    camera.constrainedAxis,
    rotateVertScratchA,
  );

  let dot = Cartesian3.dot(p, constrainedAxis);
  let angleToAxis = CesiumMath.acosClamped(dot);
  if (angle > 0 && angle > angleToAxis) {
    angle = angleToAxis - CesiumMath.EPSILON4;
  }

  dot = Cartesian3.dot(
    p,
    Cartesian3.negate(constrainedAxis, rotateVertScratchNegate),
  );
  angleToAxis = CesiumMath.acosClamped(dot);
  if (angle < 0 && -angle > angleToAxis) {
    angle = -angleToAxis + CesiumMath.EPSILON4;
  }

  const tangent = Cartesian3.cross(
    constrainedAxis,
    p,
    rotateVertScratchTan,
  );
  camera.rotate(tangent, angle);
}
```