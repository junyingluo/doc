### zoom3D

- zoomFactor \* distance \* rangeWindowRatio
  - distance 为世界坐标系下相机到拾取点的距离
  - rangeWindowRatio = (movement.endPosition.y - movement.startPosition.y) / object.\_scene.canvas.clientHeight

* 最终调用 camera.zoomIn

```js
function zoom3D(controller, startPosition, movement) {
  if (defined(movement.distance)) {
    movement = movement.distance;
  }
  const inertiaMovement = movement.inertiaEnabled;

  const ellipsoid = controller._ellipsoid;
  const scene = controller._scene;
  const camera = scene.camera;
  const canvas = scene.canvas;

  let windowPosition = zoomCVWindowPos;
  windowPosition.x = canvas.clientWidth / 2;
  windowPosition.y = canvas.clientHeight / 2;

  const ray = camera.getPickRay(windowPosition, zoomCVWindowRay);

  let intersection;
  const height = ellipsoid.cartesianToCartographic(
    camera.position,
    zoom3DCartographic,
  ).height;

  const approachingCollision =
    Math.abs(preIntersectionDistance) <
    controller.minimumPickingTerrainDistanceWithInertia;

  const needPickGlobe = inertiaMovement
    ? approachingCollision
    : height < controller._minimumPickingTerrainHeight;
  if (needPickGlobe) {
    intersection = pickPosition(controller, windowPosition, zoomCVIntersection);
  }

  let distance;
  if (defined(intersection)) {
    distance = Cartesian3.distance(ray.origin, intersection);
    preIntersectionDistance = distance;
  }

  if (!defined(distance)) {
    distance = height;
  }

  const unitPosition = Cartesian3.normalize(
    camera.position,
    zoom3DUnitPosition,
  );

  handleZoom(
    controller,
    startPosition,
    movement,
    controller.zoomFactor,
    distance,
    Cartesian3.dot(unitPosition, camera.direction),
  );
}
```

```js
function handleZoom(
  object,
  startPosition,
  movement,
  zoomFactor,
  distanceMeasure,
  unitPositionDotDirection,
) {
  let percentage = 1.0;
  if (defined(unitPositionDotDirection)) {
    percentage = CesiumMath.clamp(
      Math.abs(unitPositionDotDirection),
      0.25,
      1.0,
    );
  }

  const diff = movement.endPosition.y - movement.startPosition.y;

  // distanceMeasure should be the height above the ellipsoid.
  // When approaching the surface, the zoomRate slows and stops minimumZoomDistance above it.
  const approachingSurface = diff > 0;
  const minHeight = approachingSurface
    ? object.minimumZoomDistance * percentage
    : 0;
  const maxHeight = object.maximumZoomDistance;

  const minDistance = distanceMeasure - minHeight;
  let zoomRate = zoomFactor * minDistance;
  zoomRate = CesiumMath.clamp(
    zoomRate,
    object._minimumZoomRate,
    object._maximumZoomRate,
  );

  let rangeWindowRatio = diff / object._scene.canvas.clientHeight;
  rangeWindowRatio = Math.min(rangeWindowRatio, object.maximumMovementRatio);
  let distance = zoomRate * rangeWindowRatio;

  if (
    object.enableCollisionDetection ||
    object.minimumZoomDistance === 0.0 ||
    !defined(object._globe) // look-at mode
  ) {
    if (distance > 0.0 && Math.abs(distanceMeasure - minHeight) < 1.0) {
      return;
    }

    if (distance < 0.0 && Math.abs(distanceMeasure - maxHeight) < 1.0) {
      return;
    }

    if (distanceMeasure - distance < minHeight) {
      distance = distanceMeasure - minHeight - 1.0;
    } else if (distanceMeasure - distance > maxHeight) {
      distance = distanceMeasure - maxHeight;
    }
  }

  ......

  camera.zoomIn(distance);
  return;
}
```
