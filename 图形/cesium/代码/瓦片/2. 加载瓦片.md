### Cesium

- selectTiles 选择要下载的 tile，并保存到 \_requestedTiles

* requestTiles 下载 \_requestedTiles 中 tile

  ```
  function requestTiles(tileset) {
    const requestedTiles = tileset._requestedTiles;
    requestedTiles.sort(sortTilesByPriority);
    for (let i = 0; i < requestedTiles.length; ++i) {
      requestContent(tileset, requestedTiles[i]);
    }
  }
  ```

- fetchArrayBuffer 下载 tile
- processArrayBuffer 解析
  - processGltfJson 将解析好的 gltf 保存到 GltfJsonLoader 中 \_gltf

![alt text](<assets/2. 加载瓦片/1.png>)

### Cesium3DTile.processArrayBuffer

- 通过 tile.\_contentResource.\_url 可以查看是哪个 b3dm

* requestPromise 获取 b3dm 数据
* tile.\_content 存储解析后的数据 (Model3DTileContent)

  ![alt text](<assets/2. 加载瓦片/2.png>)

```js
async function processArrayBuffer(
  tile,
  tileset,
  request,
  expired,
  requestPromise,
) {
  const previousState = tile._contentState;
  tile._contentState = Cesium3DTileContentState.LOADING;
  let arrayBuffer = await requestPromise;
  tile._content = await makeContent(tile, arrayBuffer);
  tile._contentState = Cesium3DTileContentState.PROCESSING;
  return content;
}
```

### B3dmLoader.load

- B3dmParser.parse 进行解析
  - featureTableJson（要素表）

  ```json
  {
    "BATCH_LENGTH": 0,
    "RTC_CENTER": [-2272715.52284904, 4240615.18895731, 4174135.50342642]
  }
  ```

  - this.\_transform 根据 RTC_CENTER 生成平移矩阵

* GltfLoader.load 进行解析

```js
B3dmLoader.prototype.load = function () {
  if (defined(this._promise)) {
    return this._promise;
  }

  const b3dm = B3dmParser.parse(this._arrayBuffer, this._byteOffset);

  let batchLength = b3dm.batchLength;
  const featureTableJson = b3dm.featureTableJson;
  const featureTableBinary = b3dm.featureTableBinary;
  const batchTableJson = b3dm.batchTableJson;
  const batchTableBinary = b3dm.batchTableBinary;

  const featureTable = new Cesium3DTileFeatureTable(
    featureTableJson,
    featureTableBinary,
  );
  batchLength = featureTable.getGlobalProperty("BATCH_LENGTH");
  // Set batch length.
  this._batchLength = batchLength;
  // Set the RTC Center transform, if present.
  const rtcCenter = featureTable.getGlobalProperty(
    "RTC_CENTER",
    ComponentDatatype.FLOAT,
    3,
  );
  if (defined(rtcCenter)) {
    this._transform = Matrix4.fromTranslation(Cartesian3.fromArray(rtcCenter));
  }

  this._batchTable = {
    json: batchTableJson,
    binary: batchTableBinary,
  };

  const gltfLoader = new GltfLoader({
    typedArray: b3dm.gltf,
    upAxis: this._upAxis,
    forwardAxis: this._forwardAxis,
    gltfResource: this._b3dmResource,
    baseResource: this._baseResource,
    releaseGltfJson: this._releaseGltfJson,
    incrementallyLoadTextures: this._incrementallyLoadTextures,
    loadAttributesAsTypedArray: this._loadAttributesAsTypedArray,
    loadAttributesFor2D: this._loadAttributesFor2D,
    enablePick: this._enablePick,
    loadIndicesForWireframe: this._loadIndicesForWireframe,
    loadPrimitiveOutline: this._loadPrimitiveOutline,
    loadForClassification: this._loadForClassification,
    renameBatchIdSemantic: true,
  });

  this._gltfLoader = gltfLoader;
  this._state = B3dmLoaderState.LOADING;

  const that = this;
  this._promise = gltfLoader.load().then(function () {
    if (that.isDestroyed()) {
      return;
    }

    that._state = B3dmLoaderState.PROCESSING;
    return that;
  });

  return this._promise;
};
```

### parseGlbVersion2

```js
unction parseGlbVersion2(glb, header) {
  const length = header[2];
  let byteOffset = 12;
  let gltf;
  let binaryBuffer;
  while (byteOffset < length) {
    const chunkHeader = readHeader(glb, byteOffset, 2);
    const chunkLength = chunkHeader[0];
    const chunkType = chunkHeader[1];
    byteOffset += 8;
    const chunkBuffer = glb.subarray(byteOffset, byteOffset + chunkLength);
    byteOffset += chunkLength;
    // Load JSON chunk
    if (chunkType === 0x4e4f534a) {
      const jsonString = getStringFromTypedArray(chunkBuffer);
      gltf = JSON.parse(jsonString);
      addPipelineExtras(gltf);
    }
    // Load Binary chunk
    else if (chunkType === 0x004e4942) {
      binaryBuffer = chunkBuffer;
    }
  }
  if (defined(gltf) && defined(binaryBuffer)) {
    const buffers = gltf.buffers;
    if (defined(buffers) && buffers.length > 0) {
      const buffer = buffers[0];
      buffer.extras._pipeline.source = binaryBuffer;
    }
  }
  return gltf;
}
```

```
B3dmLoader.prototype.process = function (frameState) {
  //>>includeStart('debug', pragmas.debug);
  Check.typeOf.object("frameState", frameState);
  //>>includeEnd('debug');

  if (this._state === B3dmLoaderState.READY) {
    return true;
  }

  if (this._state !== B3dmLoaderState.PROCESSING) {
    return false;
  }

  const ready = this._gltfLoader.process(frameState);
  if (!ready) {
    return false;
  }

  const components = this._gltfLoader.components;

  // Combine the RTC_CENTER transform from the b3dm and the CESIUM_RTC
  // transform from the glTF. In practice usually only one or the
  // other is supplied. If they don't exist the transforms will
  // be identity matrices.
  components.transform = Matrix4.multiplyTransformation(
    this._transform,
    components.transform,
  );
  createStructuralMetadata(this, components);
  this._components = components;

  // Now that we have the parsed components, we can release the array buffer
  this._arrayBuffer = undefined;

  this._state = B3dmLoaderState.READY;
  return true;
};
```
