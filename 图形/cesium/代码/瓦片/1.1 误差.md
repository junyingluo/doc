### 几何误差（Geometric Error）

- 父节点比子结点几何误差要大

<img src="assets/1.1 误差/1.png" width="50%" height="50%" />

### 包围体（Bounding Volume）

<img src="assets/1.1 误差/2.png" width="50%" height="50%" />

### 屏幕空间误差（Screen Space Error, SSE）

<img src="assets/1.1 误差/1.webp" width="50%" height="50%" />

$$e_s = \frac{e_g \cdot H}{d \cdot 2 \cdot \tan(\theta_f/2)}$$

- 本质将几何误差（Geometric Error）转换为屏幕像素误差（SSE），其中，$e_s$​ 为屏幕空间误差，$e_g$​ 为几何度量误差，$H$ 为以像素为单位的渲染窗口的高度，$d$ 为视线中心与瓦片中心之间的距离，$\theta_f$​ 为视场角的
- cesium 中 sse = (geometricError ⋅ screenHeight) / (tileDistance ⋅ 2 ⋅ tan(fovy / 2))
  - screenHeight 为屏幕高度
  - tileDistance 为相机到包围体中心点的距离

```json
{
  "boundingVolume": {
    "sphere": [
      -2273572.4161012298427522, 4239503.0689686601981521,
      4174793.6053042900748551, 190.0535988252860022
    ]
  },
  "geometricError": 380.1071976505720045
}
```

### getScreenSpaceError

- useParentGeometricError 为 false，求自身的 SSE
- useParentGeometricError 为 true，判断是否提前满足

```js
Cesium3DTile.prototype.getScreenSpaceError = function (
  frameState,
  useParentGeometricError,
) {
  const tileset = this._tileset;
  const parentGeometricError = defined(this.parent)
    ? this.parent.geometricError
    : tileset._scaledGeometricError;
  const geometricError = useParentGeometricError
    ? parentGeometricError
    : this.geometricError;
  // 表示当前 tile 没有几何误差
  if (geometricError === 0.0) {
    // Leaf tiles do not have any error so save the computation
    return 0.0;
  }
  const { camera, context } = frameState;
  let frustum = camera.frustum;
  const width = context.drawingBufferWidth;
  const height = context.drawingBufferHeight;
  const distance = Math.max(this._distanceToCamera, CesiumMath.EPSILON7);
  const sseDenominator = frustum.sseDenominator;
  let error = (geometricError * height) / (distance * sseDenominator);
  if (tileset.dynamicScreenSpaceError) {
    const density = tileset._dynamicScreenSpaceErrorComputedDensity;
    const factor = tileset.dynamicScreenSpaceErrorFactor;
    const dynamicError = CesiumMath.fog(distance, density) * factor;
    error -= dynamicError;
  }

  error /= frameState.pixelRatio;

  return error;
};
```
