### Camera

- 初始化为 ECEF 坐标系

* rectangleCameraPosition3D
  - 根据 DEFAULT_VIEW_RECTANGLE 计算 up,right,direction, position

- 调整相机位置（position），即其到中心点（center）的距离拉长 DEFAULT_VIEW_FACTOR 倍

```js
function Camera(scene) {
  rectangleCameraPosition3D(
    this,
    Camera.DEFAULT_VIEW_RECTANGLE,
    this.position,
    true,
  );
  let mag = Cartesian3.magnitude(this.position);
  mag += mag * Camera.DEFAULT_VIEW_FACTOR;
  Cartesian3.normalize(this.position, this.position);
  Cartesian3.multiplyByScalar(this.position, mag, this.position);
}
```

### rectangleCameraPosition3D

- DEFAULT_VIEW_RECTANGLE
  - west（-95.0），south（-20.0），east（-70.0），north（90.0）
- 根据 DEFAULT_VIEW_RECTANGLE，求其中心点（center）的经纬度

* 根据中心点经纬度，求其 ECEF 坐标（cartographicToCartesian）

- 求中心点的法向量，而法向量的反方向，即 direction，并进一步求 up，right

* 计算相机位置（position），使得视锥体能包裹 DEFAULT_VIEW_RECTANGLE

```js
function rectangleCameraPosition3D(camera, rectangle, result, updateCamera) {
  const ellipsoid = camera._projection.ellipsoid;
  const cameraRF = updateCamera ? camera : defaultRF;

  const { north, south, west,east } = rectangle;

  // 求 rectangle 中心点的经纬度
  const longitude = (west + east) * 0.5;
  let latitude;
  if (
    south < -CesiumMath.PI_OVER_TWO + CesiumMath.RADIANS_PER_DEGREE &&
    north > CesiumMath.PI_OVER_TWO - CesiumMath.RADIANS_PER_DEGREE
  ) {
    latitude = 0.0;
  } else {
    const northCartographic = viewRectangle3DCartographic1;
    northCartographic.longitude = longitude;
    northCartographic.latitude = north;
    northCartographic.height = 0.0;

    const southCartographic = viewRectangle3DCartographic2;
    southCartographic.longitude = longitude;
    southCartographic.latitude = south;
    southCartographic.height = 0.0;

    let ellipsoidGeodesic = viewRectangle3DEllipsoidGeodesic;
    if (
      !defined(ellipsoidGeodesic) ||
      ellipsoidGeodesic.ellipsoid !== ellipsoid
    ) {
      viewRectangle3DEllipsoidGeodesic = ellipsoidGeodesic =
        new EllipsoidGeodesic(undefined, undefined, ellipsoid);
    }

    ellipsoidGeodesic.setEndPoints(northCartographic, southCartographic);
    latitude = ellipsoidGeodesic.interpolateUsingFraction(
      0.5,
      viewRectangle3DCartographic1,
    ).latitude;
  }

  const centerCartographic = viewRectangle3DCartographic1;
  centerCartographic.longitude = longitude;
  centerCartographic.latitude = latitude;
  centerCartographic.height = 0.0;

  // 将中心点经纬度转化为 ECEF 坐标
  const center = ellipsoid.cartographicToCartesian(
    centerCartographic,
    viewRectangle3DCenter,
  );

  const cart = viewRectangle3DCartographic1;
  cart.longitude = east;
  cart.latitude = north;
  const northEast = ellipsoid.cartographicToCartesian(
    cart,
    viewRectangle3DNorthEast,
  );
  cart.longitude = west;
  const northWest = ellipsoid.cartographicToCartesian(
    cart,
    viewRectangle3DNorthWest,
  );
  cart.longitude = longitude;
  const northCenter = ellipsoid.cartographicToCartesian(
    cart,
    viewRectangle3DNorthCenter,
  );
  cart.latitude = south;
  const southCenter = ellipsoid.cartographicToCartesian(
    cart,
    viewRectangle3DSouthCenter,
  );
  cart.longitude = east;
  const southEast = ellipsoid.cartographicToCartesian(
    cart,
    viewRectangle3DSouthEast,
  );
  cart.longitude = west;
  const southWest = ellipsoid.cartographicToCartesian(
    cart,
    viewRectangle3DSouthWest,
  );

  Cartesian3.subtract(northWest, center, northWest);
  Cartesian3.subtract(southEast, center, southEast);
  Cartesian3.subtract(northEast, center, northEast);
  Cartesian3.subtract(southWest, center, southWest);
  Cartesian3.subtract(northCenter, center, northCenter);
  Cartesian3.subtract(southCenter, center, southCenter);

  // 求中心点的法向量
  const direction = ellipsoid.geodeticSurfaceNormal(center, cameraRF.direction);
  // 将法向量的反方向，作为相机 direction
  Cartesian3.negate(direction, direction);
  // 求相机 right
  const right = Cartesian3.cross(direction, Cartesian3.UNIT_Z, cameraRF.right);
  Cartesian3.normalize(right, right);
  // 求相机 up
  const up = Cartesian3.cross(right, direction, cameraRF.up);

  let d;
  if (camera.frustum instanceof OrthographicFrustum) {
    ......
  } else {
    const tanPhi = Math.tan(camera.frustum.fovy * 0.5);
    const tanTheta = camera.frustum.aspectRatio * tanPhi;

    d = Math.max(
      computeD(direction, up, northWest, tanPhi),
      computeD(direction, up, southEast, tanPhi),
      computeD(direction, up, northEast, tanPhi),
      computeD(direction, up, southWest, tanPhi),
      computeD(direction, up, northCenter, tanPhi),
      computeD(direction, up, southCenter, tanPhi),
      computeD(direction, right, northWest, tanTheta),
      computeD(direction, right, southEast, tanTheta),
      computeD(direction, right, northEast, tanTheta),
      computeD(direction, right, southWest, tanTheta),
      computeD(direction, right, northCenter, tanTheta),
      computeD(direction, right, southCenter, tanTheta),
    );

    // If the rectangle crosses the equator, compute D at the equator, too, because that's the
    // widest part of the rectangle when projected onto the globe.
    if (south < 0 && north > 0) {
      const equatorCartographic = viewRectangle3DCartographic1;
      equatorCartographic.longitude = west;
      equatorCartographic.latitude = 0.0;
      equatorCartographic.height = 0.0;
      let equatorPosition = ellipsoid.cartographicToCartesian(
        equatorCartographic,
        viewRectangle3DEquator,
      );
      Cartesian3.subtract(equatorPosition, center, equatorPosition);
      d = Math.max(
        d,
        computeD(direction, up, equatorPosition, tanPhi),
        computeD(direction, right, equatorPosition, tanTheta),
      );

      equatorCartographic.longitude = east;
      equatorPosition = ellipsoid.cartographicToCartesian(
        equatorCartographic,
        viewRectangle3DEquator,
      );
      Cartesian3.subtract(equatorPosition, center, equatorPosition);
      d = Math.max(
        d,
        computeD(direction, up, equatorPosition, tanPhi),
        computeD(direction, right, equatorPosition, tanTheta),
      );
    }
  }

  return Cartesian3.add(
    center,
    Cartesian3.multiplyByScalar(direction, -d, viewRectangle3DEquator),
    result,
  );
}
function computeD(direction, upOrRight, corner, tanThetaOrPhi) {
  const opposite = Math.abs(Cartesian3.dot(upOrRight, corner));
  return opposite / tanThetaOrPhi - Cartesian3.dot(direction, corner);
}
```
