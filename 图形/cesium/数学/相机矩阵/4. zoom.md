### zoomTo

- Viewer.zoomTo $\rightarrow$ CesiumWidget.zoomTo $\rightarrow$ CesiumWidget.zoomToOrFly

```js
CesiumWidget.prototype.zoomTo = function (target, offset) {
  const options = {
    offset: offset,
  };
  return zoomToOrFly(this, target, options, false);
};
function zoomToOrFly(that, zoomTarget, options, isFlight) {
  cancelZoom(that);

  const zoomPromise = new Promise((resolve) => {
    that._completeZoom = function (value) {
      resolve(value);
    };
  });
  that._zoomPromise = zoomPromise;
  that._zoomIsFlight = isFlight;
  that._zoomOptions = options;
  that._zoomTarget = zoomTarget;

  that.scene.requestRender();
  return zoomPromise;
}
```

### updateZoomTarget

- offset 是基于 ENU 坐标系的 HeadingPitchRange

* viewBoundingSphere 调用 lookat 转化为 ENU 坐标系后计算 offset
* lookAtTransform 传入 Matrix4.IDENTITY，恢复为世界坐标系

<img src="assets/4. zoom/1.png" width="30%" height="30%" />

```js
function updateZoomTarget(widget) {
  const scene = widget.scene;
  const camera = scene.camera;
  const zoomOptions = widget._zoomOptions ?? {};
  let options;
  function zoomToBoundingSphere(boundingSphere) {
    // If offset was originally undefined then give it base value instead of empty object
    if (!defined(zoomOptions.offset)) {
      zoomOptions.offset = new HeadingPitchRange(
        0.0,
        -0.5,
        boundingSphere.radius,
      );
    }

    options = {
      offset: zoomOptions.offset,
      duration: zoomOptions.duration,
      maximumHeight: zoomOptions.maximumHeight,
      complete: function () {
        widget._completeZoom(true);
      },
      cancel: function () {
        widget._completeZoom(false);
      },
    };

    camera.viewBoundingSphere(boundingSphere, zoomOptions.offset);
    camera.lookAtTransform(Matrix4.IDENTITY);

    // Finish the promise
    widget._completeZoom(true);

    clearZoom(widget);
  }
  zoomToBoundingSphere(target.boundingSphere);
}
Camera.prototype.viewBoundingSphere = function (boundingSphere, offset) {
  this.lookAt(boundingSphere.center, offset);
};
```

### lookAt

- \_setTransform 转化为 ENU 坐标系，原点位于瓦片中心点（boundingSphere）
- 根据 offset 调整 position、right 等参数

  ```js
  Camera.prototype.lookAt = function (target, offset) {
    const scene = this._scene;
    const ellipsoid = scene.ellipsoid ?? Ellipsoid.default;

    const transform = Transforms.eastNorthUpToFixedFrame(
      target,
      ellipsoid,
      scratchLookAtMatrix4,
    );
    this.lookAtTransform(transform, offset);
  };
  Camera.prototype.lookAtTransform = function (transform, offset) {
    this._setTransform(transform);
    if (!defined(offset)) {
      return;
    }

    let cartesianOffset;
    if (defined(offset.heading)) {
      cartesianOffset = offsetFromHeadingPitchRange(
        offset.heading,
        offset.pitch,
        offset.range,
      );
    } else {
      cartesianOffset = offset;
    }

    Cartesian3.clone(cartesianOffset, this.position);
    Cartesian3.negate(this.position, this.direction);
    Cartesian3.normalize(this.direction, this.direction);
    Cartesian3.cross(this.direction, Cartesian3.UNIT_Z, this.right);

    if (Cartesian3.magnitudeSquared(this.right) < CesiumMath.EPSILON10) {
      Cartesian3.clone(Cartesian3.UNIT_X, this.right);
    }

    Cartesian3.normalize(this.right, this.right);
    Cartesian3.cross(this.right, this.direction, this.up);
    Cartesian3.normalize(this.up, this.up);
  };
  ```

* offsetFromHeadingPitchRange 计算偏移

  ```js
  CesiumMath.PI_OVER_TWO = Math.PI / 2.0;
  function offsetFromHeadingPitchRange(heading, pitch, range) {
    pitch = CesiumMath.clamp(
      pitch,
      -CesiumMath.PI_OVER_TWO,
      CesiumMath.PI_OVER_TWO,
    );
    heading = CesiumMath.zeroToTwoPi(heading) - CesiumMath.PI_OVER_TWO;

    const pitchQuat = Quaternion.fromAxisAngle(
      Cartesian3.UNIT_Y,
      -pitch,
      scratchLookAtHeadingPitchRangeQuaternion1,
    );
    const headingQuat = Quaternion.fromAxisAngle(
      Cartesian3.UNIT_Z,
      -heading,
      scratchLookAtHeadingPitchRangeQuaternion2,
    );
    const rotQuat = Quaternion.multiply(headingQuat, pitchQuat, headingQuat);
    const rotMatrix = Matrix3.fromQuaternion(
      rotQuat,
      scratchHeadingPitchRangeMatrix3,
    );

    const offset = Cartesian3.clone(
      Cartesian3.UNIT_X,
      scratchLookAtHeadingPitchRangeOffset,
    );
    Matrix3.multiplyByVector(rotMatrix, offset, offset);
    Cartesian3.negate(offset, offset);
    Cartesian3.multiplyByScalar(offset, range, offset);
    return offset;
  }
  ```
