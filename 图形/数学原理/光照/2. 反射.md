### 光源

- 光强会随着与光源距离的增加而减弱。在物理学中，点光​​源的能量与距离的平方成反比。如果光源是一条线，则光强与距离成反比。而如果光源是平面，即使距离无穷大，光强也不会减弱。

### 环境反射 (Ambient)

- 光源：来自物体周围的各个方向，物体从各个方向均匀受光

* 反射：物体向各个方向均匀反射光

* 环境光 = 材质反射系数 \* 光强度

<img src="assets/2. 反射/webgl_lighting06.png" width="50%" height="50%" />

- fragment shader

  ```c
  uniform vec4 lightAmbient;          // (r, g, b, a)
  uniform vec4 materialAmbient;       // (r, g, b, a)
  ...

  void main(void)
  {
      vec4 color;
      // compute ambient
      color = lightAmbient * materialAmbient;
      ...
  }
  ```

* http://www.songho.ca/webgl/webgl_light.html

### 漫反射 (Diffuse)

- 光源：粗糙物体表面被光源照射，因此各点的光的强度是不一样

* 反射：物体向各个方向均匀反射光

* 散射强度 = 光强度 \* $\cos \theta$
  - 散射光强度与入射角（光矢量和表面法线之间夹角 θ）的余弦值成正比
  * https://en.wikipedia.org/wiki/Lambertian_reflectance

* 散射光 = 材质反射系数 \* 散射强度

<img src="assets/2. 反射/webgl_lighting07.png" width="50%" height="50%" />

- vertex shader

  ```js
  attribute vec3 vertexPosition;          // vertex pos in object space
  attribute vec3 vertexNormal;            // normal vector in object space

  // uniforms
  uniform mat4 matrixModelView;
  uniform mat4 matrixNormal;

  // varying outputs
  varying vec3 positionVec;               // vertex position in eye space
  varying vec3 normalVec;                 // normal vector in eye space
  ...

  void main(void)
  {
      // transform vertex position from object space to eye space
      positionVec = (matrixModelView * vec4(vertexPosition, 1.0)).xyz;

      // transform the normal vector from object space to eye space
      // assume vertexNormal is already normalized
      normalVec = (matrixNormal * vec4(vertexNormal, 1.0)).xyz;
      ...
  }
  ```

* fragment shader

  ```js
  // uniforms
  uniform vec4 lightPosition;             // light pos in the eye space
  uniform vec4 lightDiffuse;              // (r, g, b, a)
  uniform vec4 materialDiffuse;           // (r, g, b, a)

  // input varyings
  varying vec3 positionVec;               // vertex position in eye space
  varying vec3 normalVec;                 // normal vector in eye space
  ...

  void main(void)
  {
      // re-normalize normal vector in eye space
      vec3 normal = normalize(normalVec);

      // compute light vector in eye space
      vec3 light = lightPosition.xyz - positionVec;
      light = normalize(light);

      // compute diffuse component using Lambert cosine law
      float dotNL = max(dot(normal, light), 0.0);
      vec4 color = dotNL * materialDiffuse * lightColor;
      ...
  }
  ```

### 镜面反射 (Specular)

- 光源：光滑物体表面被光源照射，因此各点的光的强度是不一样

* 反射：物体向特定方向反射光

* 镜面强度 = 光强度 \* $(\cos \theta)^s$ = 光强度 \* $(\vec{V} \cdot \vec{R})^s$
  - 视线与反射线夹角 $\theta$
  - 材质光泽度 $s$
  - 反射方向 $\vec{R} = 2(\vec{L} \cdot \vec{N})\vec{N} - \vec{L}$
  * https://en.wikipedia.org/wiki/Phong_reflection_model

- 镜面光 = 材质反射系数 \* 镜面强度

<img src="assets/2. 反射/webgl_lighting08.png" width="50%" height="50%" />

- fragment shader

  ```js
  // uniforms
  uniform vec4 lightPosition;             // light pos in the eye space
  uniform vec4 lightSpecular;             // (r, g, b, a)
  uniform vec4 materialSpecular;          // (r, g, b, a)
  uniform float materialShininess;        // shininess scale

  // input varyings
  varying vec3 positionVec;               // vertex position in eye space
  varying vec3 normalVec;                 // normal vector in eye space
  ...

  void main(void)
  {
      // re-normalize normal vector in eye space
      vec3 normal = normalize(normalVec);

      // compute positional light vector in eye space
      vec3 light = lightPosition.xyz - positionVec;
      light = normalize(light);

      // compute view vector in eye space
      vec3 view = normalize(-positionVec);

      // compute reflection vector: 2 * (N dot L) * N - L
      vec3 reflectVec = reflect(-light, normal);

      // compute specular component using Phong's model
      float dotVR = max(dot(view, reflectVec), 0.0);
      vec4 color = pow(dotVR, materialShininess) * lightSpecular * materialSpecular;
      ...
  }
  ```
