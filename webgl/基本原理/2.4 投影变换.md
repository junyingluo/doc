### 基本概念

- 将观察空间{l~r,b~t,n~f}映射到设备空间{-1~1,-1~1,-1~1}

- 相机坐标系中 z 轴朝屏幕外，因此 f<n<0

### 正投影

- 可视化

![alt text](../../3d/webgl/基本原理/assets/p1.png)

- 投影矩阵

$$
\begin{bmatrix}
\dfrac{2}{r-l} & 0 & 0 & -\dfrac{r+l}{r-l} \\
0 & \dfrac{2}{t-b} & 0 & -\dfrac{t+b}{t-b} \\
0 & 0 & \dfrac{-2}{f-n} & -\dfrac{f+n}{f-n} \\
0 & 0 & 0 & 1
\end{bmatrix}
$$

- 代码

```js
function glOrtho(l, r, b, t, n, f) {
  var matrix = new Array(4).fill(0).map(() => new Array(4).fill(0));
  matrix[0] = 2 / (r - l);
  matrix[5] = 2 / (t - b);
  matrix[10] = -2 / (f - n);
  matrix[12] = -(r + l) / (r - l);
  matrix[13] = -(t + b) / (t - b);
  matrix[14] = -(f + n) / (f - n);
  return matrix;
}
```

- 如果 r+l=0 (2r=width) 且 t+b=0 (2r=height)，可以进一步简化

$$
\begin{bmatrix}
\dfrac{1}{r} & 0 & 0 & 0 \\
0 & \dfrac{1}{t} & 0 & 0 \\
0 & 0 & \dfrac{-2}{f-n} & -\dfrac{f+n}{f-n} \\
0 & 0 & 0 & 1
\end{bmatrix}
$$

### 透视投影

- 可视化

![alt text](../../3d/webgl/基本原理/assets/p2.png)

- 投影矩阵

$$
\begin{bmatrix}
\dfrac{2n}{r-l} & 0 & \dfrac{r+l}{r-l} & 0 \\
0 & \dfrac{2n}{t-b} & \dfrac{t+b}{t-b} & 0 \\
0 & 0 & -\dfrac{f+n}{f-n} & -\dfrac{2fn}{f-n} \\
0 & 0 & -1 & 1
\end{bmatrix}
$$

- 代码

```js
function glPerspective(
  fovY /*观察角度*/,
  aspect /*视景体的宽高比*/,
  zNear,
  zFar,
) {
  var tangent = Math.tan(fovY / 2);
  var height = zNear * tangent;
  var width = height * aspect;
  glFrustum(-width, width, -height, height, zNear, zFar);
}

function glFrustum(l, r, b, t, n, f) {
  var matrix = new Array(4).fill(0).map(() => new Array(4).fill(0));
  matrix[0] = (2 * n) / (r - l);
  matrix[5] = (2 * n) / (t - b);
  matrix[8] = (r + l) / (r - l);
  matrix[9] = (t + b) / (t - b);
  matrix[10] = -(f + n) / (f - n);
  matrix[11] = -1;
  matrix[14] = -(2 * f * n) / (f - n);
  return matrix;
}
```

### z-fighting

- 在透视投影中，深度变化并不是线性，在 f-n 很大的情况下，在远平面附近，z_e 很大的变化对应 z_n 很小的变化，因而会导致一个深度精度问题，称为 z-fighting
  ![alt text](<../../3d/webgl/基本原理/assets/2.4 投影变换/z.png>)

* 当几何图形或者物体的两个表面极为接近时，就会使得表面看上去斑斑点点，这种现象称为深度冲突(z-fighting)
  ![alt text](<../../3d/webgl/基本原理/assets/2.4 投影变换/z1.png>)

- 之所以会产生深度冲突，是因为两个表面过于接近，深度缓冲区的精度已经不能区分前后。可以启用多边形偏移，该机制将会自动在 z 值加上一个偏移量
  - gl.enable(gl.POLYGON_OFFSEF_FILL)

  - gl.polygonOffset(factor, units)
    - 偏移值计算公式为 $offset = (m \cdot factor) + (r \cdot units)$，其中：

    - m 是多边形的深度的斜率，一个多边形越是与近裁剪面（near clipping plan）平行，m 就越接近 0。
    - r 是可分辨的差异的最小值，由具体实现 OpenGL 的平台指定的一个常量

- 一般 polygonOffset 取(1,0)或(1,1)即可

  ![alt text](<../../3d/webgl/基本原理/assets/2.4 投影变换/z2.png>)
