### 驱动程序

- class_create：在 /sys/class/ 下创建一个类目录（如 my_class），用于分类设备。
- device_create：在 /sys/class/my_class 下创建设备实例，同时向 udev 发送 uevent

### 示例

```c
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>

static dev_t dev_num;          // 设备号
static struct cdev my_cdev;    // 字符设备结构体
static struct class *my_class; // 设备类（用于 sysfs 分类）
static struct device *my_dev;  // 设备实例

// 打开/关闭等回调函数（省略）
static struct file_operations fops = {
    .owner = THIS_MODULE,
    // ... 其他回调
};

static int __init mydev_init(void) {
    // 1. 分配设备号（动态或静态）
    alloc_chrdev_region(&dev_num, 0, 1, "mydev");

    // 2. 初始化字符设备并添加到内核
    cdev_init(&my_cdev, &fops);
    cdev_add(&my_cdev, dev_num, 1);

    // 3. 创建设备类（在 /sys/class/ 下生成目录）
    my_class = class_create(THIS_MODULE, "my_class");
    if (IS_ERR(my_class)) {
        // 错误处理
    }

    // 4. 创建设备实例（触发 udev 事件）
    my_dev = device_create(my_class, NULL, dev_num, NULL, "mydev0");
    if (IS_ERR(my_dev)) {
        // 错误处理
    }

    return 0;
}

static void __exit mydev_exit(void) {
    device_destroy(my_class, dev_num);  // 销毁设备实例
    class_destroy(my_class);            // 销毁设备类
    cdev_del(&my_cdev);                 // 移除字符设备
    unregister_chrdev_region(dev_num, 1); // 释放设备号
}

module_init(mydev_init);
module_exit(mydev_exit);
MODULE_LICENSE("GPL");
```
