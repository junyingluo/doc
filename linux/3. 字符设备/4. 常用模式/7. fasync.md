- 驱动层

  - 在阻塞模式基础上，实现 fasync 接口，调用 fasync_helper 初始化

  ```c++
  struct mydemo_device {
  	char name[64];
  	struct device *dev;
  				wait_queue_head_t read_queue;
  	wait_queue_head_t write_queue;
  	struct kfifo mydemo_fifo;
  	struct fasync_struct *fasync;
  };
  struct mydemo_private_data {
  	struct mydemo_device *device;
  	char name[64];
  };
  // on：1 = 添加到异步队列; 0 = 从队列中删除
  static int demodrv_fasync(int fd, struct file *file, int on)
  {
  	struct mydemo_private_data *data = file->private_data;
  	struct mydemo_device *device = data->device;

  	return fasync_helper(fd, file, on, &device->fasync);
  }
  ```

  - void kill_fasync(struct fasync_struct \*\*fp, int sig, int band)

    - 普通设备 → 用 SIGIO，如果用户设置了 signum，则发送 signum，否则发送 SIGIO
    - TCP → 用 SIGURG，如果用户设置了 signum，则发送 signum，否则不发送

  * read，当 buf 不满时，通过 kill_fasync 通知可写

  ```c
  demodrv_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
  {
  	......

  	if (!kfifo_is_full(&device->mydemo_fifo)){
  		wake_up_interruptible(&device->write_queue);
  		if (file->f_flags & FASYNC)
  			kill_fasync(&device->fasync, SIGIO, POLL_OUT);
  	}

  	return actual_readed;
  }
  ```

  - write，当 buf 不为空时，通过 kill_fasync 通知可读

  ```c
  static ssize_t
  demodrv_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
  {
  	......

  	if (!kfifo_is_empty(&device->mydemo_fifo)) {
  		wake_up_interruptible(&device->read_queue);
  		if (file->f_flags & FASYNC)
  			kill_fasync(&device->fasync, SIGIO, POLL_IN);
  		printk("%s kill fasync\n", __func__);
  	}

  	return actual_write;
  }
  ```

- 用户层

```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <errno.h>
#include <poll.h>
#include <signal.h>

static int fd;

void my_signal_fun(int signum, siginfo_t *siginfo, void *act)
{
	int ret;
	char buf[64];

	if (signum == SIGIO) {
		if (siginfo->si_band & POLLIN) {
			printf("FIFO is not empty\n");
			if ((ret = read(fd, buf, sizeof(buf))) != -1) {
				buf[ret] = '\0';
				puts(buf);
			}
		}
		if (siginfo->si_band & POLLOUT)
			printf("FIFO is not full\n");
	}
}

int main(int argc, char *argv[])
{
	int ret;
	int flag;
	struct sigaction act, oldact;

	sigemptyset(&act.sa_mask);
	sigaddset(&act.sa_mask, SIGIO);
	act.sa_flags = SA_SIGINFO;
	act.sa_sigaction = my_signal_fun;
	if (sigaction(SIGIO, &act, &oldact) == -1)
		goto fail;

	fd = open("/dev/mydemo0", O_RDWR);
	if (fd < 0)
		goto fail;

	/*设置异步IO所有权*/
	if (fcntl(fd, F_SETOWN, getpid()) == -1)
		goto fail;

	/*将当前进程PID设置为fd文件所对应驱动程序将要发送SIGIO,SIGUSR信号进程PID*/
	if (fcntl(fd, F_SETSIG, SIGIO) == -1)
		goto fail;

	/*获取文件flags*/
	if ((flag = fcntl(fd, F_GETFL)) == -1)
		goto fail;

	/*设置文件flags, 设置FASYNC,支持异步通知*/
	if (fcntl(fd, F_SETFL, flag | FASYNC) == -1)
		goto fail;

	while (1)
		sleep(1);

fail:
	perror("fasync test");
	exit(EXIT_FAILURE);
}
```
