- 驱动层

  - 在阻塞模式基础上，实现 poll 接口

  * 当用户程序打开设备文件后执行 poll 或 select 系统调用时，设备驱动的 poll() 方法就会被调用。设备驱动的 poll() 方法会执行如下步骤：

    - 在一个或多个等待队列中调用 poll_wait() 函数。poll_wait() 函数会把当前进程添加到指定的等待列表（poll table）中，当请求数据准备好之后，会唤醒这些睡眠的进程。

    - 内核根据 poll 返回值，决定是否进入阻塞。**如果返回为 0，说明没有事件，则进入阻塞**。

  ```c
  static unsigned int demodrv_poll(struct file *file, poll_table *wait)
  {
    int mask = 0;
    struct mydemo_private_data *data = file->private_data;
    struct mydemo_device *device = data->device;

    poll_wait(file, &device->read_queue, wait);
    poll_wait(file, &device->write_queue, wait);

    if (!kfifo_is_empty(&device->mydemo_fifo))
      mask |= POLLIN | POLLRDNORM;
    if (!kfifo_is_full(&device->mydemo_fifo))
      mask |= POLLOUT | POLLWRNORM;

    return mask;
  }
  ```

- 内核层

  - poll 每次对所有 fd 进行一次扫描（调用 poll），核心代码在 do_poll 本质就是一个大的 for 循环

  - static int do_poll(struct poll_list *list, struct poll_wqueues *wait, struct timespec64 \*end_time)

- 用户层

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <sys/ioctl.h>
  #include <fcntl.h>
  #include <errno.h>
  #include <poll.h>
  #include <linux/input.h>
  #include <unistd.h>

  int main(int argc, char *argv[])
  {
  	int ret;
  	struct pollfd fds[2];
  	char buffer0[64];
  	char buffer1[64];

  	fds[0].fd = open("/dev/mydemo0", O_RDWR);
  	if (fds[0].fd == -1)
  		goto fail;
  	fds[0].events = POLLIN;

  	fds[1].fd = open("/dev/mydemo1", O_RDWR);
  	if (fds[1].fd == -1)
  		goto fail;
  	fds[1].events = POLLIN;

  	while (1) {
  		ret = poll(fds, 2, -1);
  		if (ret == -1)
  			goto fail;

  		if (fds[0].revents & POLLIN) {
  			ret = read(fds[0].fd, buffer0, sizeof(buffer0));
  			if (ret < 0)
  				goto fail;
  			printf("%s\n", buffer0);
  		}

  		if (fds[1].revents & POLLIN) {
  			ret = read(fds[1].fd, buffer1, sizeof(buffer1));
  			if (ret < 0)
  				goto fail;

  			printf("%s\n", buffer1);
  		}
  	}

  fail:
  	perror("poll test failed");
  	exit(EXIT_FAILURE);
  }
  ```
