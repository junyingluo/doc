- 驱动层

  - 读取时，如果 buf 为空且 f_flags 设置了 O_NONBLOCK，返回 -EAGAIN (暂时不可用，请稍后再试)

  - 写入时，如果 buf 已满且 f_flags 设置了 O_NONBLOCK，返回 -EAGAIN (暂时不可用，请稍后再试)

  ```c
  static ssize_t
  demodrv_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
  {
    int actual_readed;
    int ret;

    if (kfifo_is_empty(&mydemo_fifo)) {
      if (file->f_flags & O_NONBLOCK)
        return -EAGAIN;
    }

    ret = kfifo_to_user(&mydemo_fifo, buf, count, &actual_readed);
    if (ret)
      return -EIO;

    printk("%s, actual_readed=%d, pos=%lld\n",__func__, actual_readed, *ppos);
    return actual_readed;
  }

  static ssize_t
  demodrv_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
  {
    unsigned int actual_write;
    int ret;

    if (kfifo_is_full(&mydemo_fifo)){
      if (file->f_flags & O_NONBLOCK)
        return -EAGAIN;
    }

    ret = kfifo_from_user(&mydemo_fifo, buf, count, &actual_write);
    if (ret)
      return -EIO;

    printk("%s: actual_write =%d, ppos=%lld, ret=%d\n", __func__, actual_write, *ppos, ret);

    return actual_write;
  }
  ```

* 用户层，采用轮询的方式

  - open 时，设置 O_NONBLOCK
    - fd = open(DEMO_DEV_NAME, O_RDWR | O_NONBLOCK);

  * 如果错误为 EAGAIN，则重试

  ```c
  int fd = open(DEMO_DEV_NAME, O_RDWR | O_NONBLOCK);
  while (true) {
    int ret = write(fd, data, len);
    if (ret < 0 && errno == EAGAIN) {
        continue;
    }
  }
  ```
