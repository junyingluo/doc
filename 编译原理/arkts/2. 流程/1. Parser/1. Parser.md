### 主要工作

```js
function add(x: number) {
  return x++;
}
add(1);
```

生成

```json
{
  "type": "Program",
  "statements": [
    {
      "type": "FunctionDeclaration"
    },
    {
      "type": "ExpressionStatement"
    }
  ]
}
```

### 入口

- ParsePackageDeclaration()

  设置 moduleName 为 test.sts

  GetProgram()->SetPackageInfo(moduleName, ModuleKind::MODULE);

- AddExternalSource(ParseSources(true)) 好像什么都不做

  ```c++
  void ETSParser::ParseProgram(ScriptKind kind)
  {
      lexer::SourcePosition startLoc = Lexer()->GetToken().Start();
      Lexer()->NextToken();
      GetProgram()->SetKind(kind);

      ArenaVector<ir::Statement *> statements(Allocator()->Adapter());

      ir::ETSModule *script = ParseETSGlobalScript(startLoc, statements);
      GetProgram()->SetAst(script);
  }
  ```

## ParseETSGlobalScript

- ParseImportDeclarations

  解析 import

- ParseTopLevelDeclaration

  ```c++
  ir::ETSModule *ETSParser::ParseETSGlobalScript(lexer::SourcePosition startLoc, ArenaVector<ir::Statement *> &statements)
  {
      auto topLevelStatements = ParseTopLevelDeclaration();
      statements.insert(statements.end(), topLevelStatements.begin(), topLevelStatements.end());

      auto ident = AllocNode<ir::Identifier>(compiler::Signatures::ETS_GLOBAL, Allocator());
      auto *etsModule =
          AllocNode<ir::ETSModule>(Allocator(), std::move(statements), ident, ir::ModuleFlag::ETSSCRIPT, GetProgram());
      etsModule->SetRange({startLoc, Lexer()->GetToken().End()});
      return etsModule;
  }
  ```
