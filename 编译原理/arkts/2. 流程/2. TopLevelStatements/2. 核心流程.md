- Perform

  - 对每个 program 执行 HandleGlobalStmts、SetupGlobalClass

  ```c++
  bool TopLevelStatements::Perform(public_lib::Context *ctx, parser::Program *program)
  {
      ......
      GlobalClassHandler globalClass(ctx->parser->AsETSParser(), program->Allocator());
      for (auto &[package, extPrograms] : program->ExternalSources()) {
          auto moduleDependencies = imports.HandleGlobalStmts(extPrograms);
          globalClass.SetupGlobalClass(extPrograms, &moduleDependencies);
      }

      ArenaVector<parser::Program *> mainModule(program->Allocator()->Adapter());
      mainModule.emplace_back(program);
      auto moduleDependencies = imports.HandleGlobalStmts(mainModule);
      globalClass.SetupGlobalClass(mainModule, &moduleDependencies);
      return true;
  }
  ```

* HandleGlobalStmts

* SetupGlobalClass

  - 作用

    ```
    function show(x: int) {
      console.log(x);
    }
    show(1);
    ------------------------------------------------
    abstract class ETSGLOBAL {
      public static main() {}

      public static _$init$_() {
        show(1);
      }

      public static show(x: int) {
        console.log(x);
      }

      static {
        _$init$_();
      }
    }
    ```

  - 创建 ETSGLOBAL（ClassDeclaration）
  - 将 AST 根节点（ETSModule）中 statements 挪到 ETSGLOBAL 中
  - 将 ETSGLOBAL（ClassDeclaration）插入 AST 根节点
  - 将 ETSGLOBAL（ClassDefinition）保存到 globalClass\_

    ```c++
    void GlobalClassHandler::SetupGlobalClass(const ArenaVector<parser::Program *> &programs,
                                          const ModuleDependencies *moduleDependencies)
    {
        if (programs.empty()) {
            return;
        }
        parser::Program *const globalProgram = programs.front();
        ir::ClassDeclaration *const globalDecl = CreateGlobalClass(globalProgram);
        ir::ClassDefinition *const globalClass = globalDecl->Definition();

        // NOTE(vpukhov): a clash inside program list is possible
        ES2PANDA_ASSERT(globalProgram->IsPackage() || programs.size() == 1);

        ArenaVector<GlobalStmts> statements(allocator_->Adapter());
        ArenaVector<ir::ETSModule *> namespaces(allocator_->Adapter());

        for (auto program : programs) {
            program->Ast()->IterateRecursively([this](ir::AstNode *node) { AddStaticBlockToClass(node); });
            auto &body = program->Ast()->Statements();
            auto stmts = CollectProgramGlobalStatements(body, globalClass, program->Ast());
            auto end = std::remove_if(body.begin(), body.end(), [&namespaces](ir::AstNode *node) {
                if (node->IsETSModule() && node->AsETSModule()->IsNamespace()) {
                    namespaces.emplace_back(node->AsETSModule());
                    return true;
                }
                return false;
            });
            body.erase(end, body.end());
            // NOTE: Initializer block for Package is to be done(xingshunxiang).
            statements.emplace_back(GlobalStmts {program, std::move(stmts[0])});
            // 保存到 globalClass_
            program->SetGlobalClass(globalClass);
        }

        globalProgram->Ast()->Statements().emplace_back(globalDecl);
        globalDecl->SetParent(globalProgram->Ast());
        globalClass->SetGlobalInitialized();

        CollectProgramGlobalClasses(globalProgram, namespaces);

        // NOTE(vpukhov): stdlib checks are to be removed - do not extend the existing logic
        if (globalProgram->Kind() != parser::ScriptKind::STDLIB) {
            AddStaticBlockToClass(globalClass);
            if (!util::Helpers::IsStdLib(globalProgram)) {
                auto initStatements = FormInitMethodStatements(globalProgram, moduleDependencies, std::move(statements));
                SetupGlobalMethods(globalProgram, std::move(initStatements));
            }
        }
    }
    ```

  - SetupGlobalMethods

    ```c++
    void GlobalClassHandler::SetupGlobalMethods(parser::Program *program, ArenaVector<ir::Statement *> &&initStatements)
    {
        ir::ClassDefinition *const globalClass = program->GlobalClass();

        auto const insertInGlobal = [globalClass](ir::AstNode *node) {
            globalClass->Body().insert(globalClass->Body().begin(), node);
            node->SetParent(globalClass);
        };

        if (!program->IsDeclarationModule()) {
            // 创建 _$init$_ 方法
            ir::MethodDefinition *initMethod =
                CreateGlobalMethod(compiler::Signatures::INIT_METHOD, std::move(initStatements), program);
            // 插入到 globalClass
            insertInGlobal(initMethod);
            // 创建 globalClass 的 static {}，并将 _$init$_ 插入
            if (!initMethod->Function()->Body()->AsBlockStatement()->Statements().empty()) {
                AddInitCallFromStaticBlock(globalClass, initMethod);
            }
        }

        if (program->IsSeparateModule() && !HasMethod(globalClass, compiler::Signatures::MAIN)) {
            // 创建 main 方法
            ir::MethodDefinition *mainMethod = CreateGlobalMethod(
                compiler::Signatures::MAIN, ArenaVector<ir::Statement *>(allocator_->Adapter()), program);
            insertInGlobal(mainMethod);
        }
    }
    ```
