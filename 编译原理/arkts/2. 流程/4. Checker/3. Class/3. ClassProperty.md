```c++
checker::Type *ETSAnalyzer::Check(ir::ClassProperty *st) const
{
    if (st->TsType() != nullptr) {
        return st->TsType();
    }

    ES2PANDA_ASSERT(st->Id() != nullptr);

    ETSChecker *checker = GetETSChecker();

    if (st->Id()->Variable() == nullptr) {
        st->Id()->Check(checker);
    }

    ES2PANDA_ASSERT(st->Id()->Variable() != nullptr);

    checker->CheckAnnotations(st->Annotations());
    if (st->TypeAnnotation() != nullptr) {
        st->TypeAnnotation()->Check(checker);
    }
    checker::SavedCheckerContext savedContext(checker, checker->Context().Status(),
                                              checker->Context().ContainingClass(),
                                              checker->Context().ContainingSignature());

    if (st->IsStatic()) {
        checker->AddStatus(checker::CheckerStatus::IN_STATIC_CONTEXT);
    }

    checker::Type *propertyType =
        checker->CheckVariableDeclaration(st->Id(), st->TypeAnnotation(), st->Value(), st->Modifiers());

    return st->SetTsType(propertyType != nullptr ? propertyType : checker->GlobalTypeError());
}
```

### CheckVariableDeclaration

- TypeAnnotation

```c++
checker::Type *ETSChecker::CheckVariableDeclaration(ir::Identifier *ident, ir::TypeNode *typeAnnotation,
                                                    ir::Expression *init, ir::ModifierFlags const flags)
{
    varbinder::Variable *const bindingVar = ident->Variable();
    checker::Type *annotationType = nullptr;

    // We have to process possible parser errors when variable was not created and bind:
    if (bindingVar != nullptr) {
        if (typeAnnotation != nullptr) {
            annotationType = typeAnnotation->GetType(this);
            bindingVar->SetTsType(annotationType);
        }

        if (init == nullptr) {
            return FixOptionalVariableType(bindingVar, flags, init);
        }
        CheckAssignForDeclare(ident, typeAnnotation, init, flags, this);
    } else {
        ES2PANDA_ASSERT(IsAnyError());
    }

    checker::Type *initType = nullptr;
    if (init != nullptr) {
        TypeStackElement typeStackElement(this, init, {"Circular dependency detected for identifier: ", ident->Name()},
                                          init->Start());
        if (typeStackElement.HasTypeError()) {
            return init->SetTsType(GlobalTypeError());
        }

        // SUPPRESS_CSA_NEXTLINE(alpha.core.AllocatorETSCheckerHint)
        if (!CheckInit(ident, typeAnnotation, init, annotationType, bindingVar)) {
            init->SetTsType(GlobalTypeError());
        } else {
            initType = init->Check(this);
        }
    } else {
        ES2PANDA_ASSERT(IsAnyError());
    }

    // initType should not be nullptr. If an error occurs during check, set it to GlobalTypeError().
    if (bindingVar == nullptr || initType == nullptr || initType->IsTypeError()) {
        return annotationType != nullptr ? annotationType : GlobalTypeError();
    }

    if (typeAnnotation == nullptr && initType->IsETSFunctionType()) {
        annotationType = initType->AsETSFunctionType();
        bindingVar->SetTsType(annotationType);
    }

    if (annotationType != nullptr) {
        if (typeAnnotation != nullptr) {
            CheckRecordType(init, annotationType, this);
            AssignmentContext(Relation(), init, initType, annotationType, init->Start(),
                              {"Type '", initType, "' cannot be assigned to type '", annotationType, "'"});
            if (!Relation()->IsTrue()) {
                return annotationType;
            }
        }

        if (IsOmitConstInit(flags) && ShouldPreserveConstantTypeInVariableDeclaration(annotationType, initType)) {
            bindingVar->SetTsType(init->TsType());
        }
    } else {
        CheckEnumType(init, initType, ident->Name());

        // NOTE: need to be done by smart casts
        auto needWidening = !IsOmitConstInit(flags) && typeAnnotation == nullptr && NeedWidening(init);
        bindingVar->SetTsType(needWidening ? GetNonConstantType(initType) : initType);
    }

    return FixOptionalVariableType(bindingVar, flags, init);
}
```
