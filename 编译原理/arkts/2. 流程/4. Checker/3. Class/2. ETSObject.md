```c++
ETSObjectType *ETSChecker::CreateETSObjectTypeOrBuiltin(ir::AstNode *declNode, ETSObjectFlags flags)
{
    if (LIKELY(HasStatus(CheckerStatus::BUILTINS_INITIALIZED))) {
        return CreateETSObjectType(declNode, flags);
    }
    auto const globalId = GetGlobalTypesHolder()->NameToId(GetObjectTypeDeclNames(declNode).first);
    if (!globalId.has_value()) {
        return CreateETSObjectType(declNode, flags);
    }
    return InitializeGlobalBuiltinObjectType(this, globalId.value(), declNode, flags);
}

ETSObjectType *ETSChecker::CreateETSObjectType(ir::AstNode *declNode, ETSObjectFlags flags)
{
    auto const [name, internalName] = GetObjectTypeDeclNames(declNode);

    if (declNode->IsClassDefinition() && (declNode->AsClassDefinition()->IsEnumTransformed())) {
        if (declNode->AsClassDefinition()->IsIntEnumTransformed()) {
            return Allocator()->New<ETSIntEnumType>(Allocator(), name, internalName, declNode, Relation());
        }
        ES2PANDA_ASSERT(declNode->AsClassDefinition()->IsStringEnumTransformed());
        return Allocator()->New<ETSStringEnumType>(Allocator(), name, internalName, declNode, Relation());
    }

    if (auto [lang, hasDecl] = CheckForDynamicLang(declNode, internalName); lang.IsDynamic()) {
        return Allocator()->New<ETSDynamicType>(Allocator(), std::make_tuple(name, internalName, lang),
                                                std::make_tuple(declNode, flags, Relation()), hasDecl);
    }

    return Allocator()->New<ETSObjectType>(Allocator(), name, internalName,
                                           std::make_tuple(declNode, flags, Relation()));
}
```
