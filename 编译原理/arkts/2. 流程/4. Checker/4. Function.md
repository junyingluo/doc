### ScriptFunction

- AstNode - Statement
  - AnnotationAllowed<AstNode>
    - ScriptFunction

* Parser 阶段相关成员变量

  - Identifier \*id\_
  - FunctionSignature irSignature\_
  - AstNode \*body\_;
  - ArenaVector<ReturnStatement \*> returnStatements\_;

* Bind 阶段相关成员变量

  - varbinder::FunctionScope \*scope\_

* Checker 阶段相关成员变量
  - checker::Signature \*signature\_

### Signature

- 相同变量名，有不同的函数签名，当调用一个函数时，会从该 ETSFunctionType 总

### BuildMethodSignature

```c++
checker::Type *ETSChecker::BuildMethodSignature(ir::MethodDefinition *method)
{
    if (method->TsType() != nullptr) {
        return method->TsType()->AsETSFunctionType();
    }

    method->Function()->Id()->SetVariable(method->Id()->Variable());
    BuildFunctionSignature(method->Function(), method->IsConstructor());
    if (method->Function()->Signature() == nullptr) {
        return method->Id()->Variable()->SetTsType(GlobalTypeError());
    }
    auto *funcType = BuildMethodType(method->Function());
    method->InitializeOverloadInfo();
    if (!CollectOverload(this, method, funcType)) {
        return GlobalTypeError();
    }
    ir::OverloadInfo &ldInfo = method->GetOverloadInfo();

    ldInfo.needHelperOverload &= ldInfo.isDeclare;
    if (ldInfo.needHelperOverload) {
        Warning("Function " + std::string(funcType->Name()) + " with this assembly signature already declared.",
                method->Start());
    }

    return method->Id()->Variable()->SetTsType(funcType);
}
```

### BuildFunctionSignature

```c++
void ETSChecker::BuildFunctionSignature(ir::ScriptFunction *func, bool isConstructSig)
{
    bool isArrow = func->IsArrow();
    auto *nameVar = isArrow ? nullptr : func->Id()->Variable();
    auto funcName = nameVar == nullptr ? util::StringView() : nameVar->Name();

    if ((func->IsConstructor() || !func->IsStatic()) && !func->IsArrow()) {
        auto thisVar = func->Scope()->ParamScope()->Params().front();
        thisVar->SetTsType(Context().ContainingClass());
    }
    auto *signatureInfo = ComposeSignatureInfo(func->TypeParams(), func->Params());
    auto *returnType = func->GetPreferredReturnType() != nullptr
                           ? func->GetPreferredReturnType()
                           : ComposeReturnType(func->ReturnTypeAnnotation(), func->IsAsyncFunc());
    auto *signature = ComposeSignature(func, signatureInfo, returnType, nameVar);
    if (signature == nullptr) {  // #23134
        ES2PANDA_ASSERT(IsAnyError());
        return;
    }

    func->SetSignature(signature);

    if (isConstructSig) {
        signature->AddSignatureFlag(SignatureFlags::CONSTRUCT);
    } else {
        signature->AddSignatureFlag(SignatureFlags::CALL);
    }

    if (funcName.Is(compiler::Signatures::MAIN) &&
        func->Scope()->Name().Utf8().find(compiler::Signatures::ETS_GLOBAL) != std::string::npos) {
        func->AddFlag(ir::ScriptFunctionFlags::ENTRY_POINT);
    }
    if (func->IsEntryPoint()) {
        ValidateMainSignature(func);
    }

    VarBinder()->AsETSBinder()->BuildFunctionName(func);
}
```

### ComposeSignatureInfo

```c++
SignatureInfo *ETSChecker::ComposeSignatureInfo(ir::TSTypeParameterDeclaration *typeParams,
                                                ArenaVector<ir::Expression *> const &params)
{
    auto *const signatureInfo = CreateSignatureInfo();

    if (typeParams != nullptr) {
        auto [typeParamTypes, ok] = CreateUnconstrainedTypeParameters(typeParams);
        signatureInfo->typeParams = std::move(typeParamTypes);
        if (ok) {
            AssignTypeParameterConstraints(typeParams);
        }
    }

    for (auto *const p : params) {
        if (!p->IsETSParameterExpression() ||
            !AppendSignatureInfoParam(this, signatureInfo, p->AsETSParameterExpression())) {  // #23134
            ES2PANDA_ASSERT(IsAnyError());
            return nullptr;
        }
    }

    if (!params.empty()) {
        if (auto param = params.back()->AsETSParameterExpression(); param->IsRestParameter()) {
            if (param->TypeAnnotation() == nullptr) {  // #23134
                ES2PANDA_ASSERT(IsAnyError());
                return nullptr;
            }
            signatureInfo->restVar = SetupSignatureParameter(param, param->TypeAnnotation()->GetType(this));
            ES2PANDA_ASSERT(signatureInfo->restVar != nullptr);
        }
    }

    return signatureInfo;
}
```

- AppendSignatureInfoParam

  - TypeAnnotation 即 int
  - sigInfo->params

```c++
static bool AppendSignatureInfoParam(ETSChecker *checker, SignatureInfo *sigInfo, ir::ETSParameterExpression *param)
{

    auto variable = SetupSignatureParameter(param, [checker, param]() {
        if (param->TypeAnnotation() != nullptr) {
            auto type = param->TypeAnnotation()->GetType(checker);
            return param->IsOptional() ? checker->CreateETSUnionType({type, checker->GlobalETSUndefinedType()}) : type;
        }
        ......
        return checker->GlobalTypeError();
    }());

    sigInfo->params.push_back(variable);
    ......
    return true;
}
static varbinder::LocalVariable *SetupSignatureParameter(ir::ETSParameterExpression *param, Type *type)
{
    auto *const variable = param->Ident()->Variable();  // #23134
    param->Ident()->SetTsType(type);
    variable->SetTsType(type);
    return variable->AsLocalVariable();
}
```
