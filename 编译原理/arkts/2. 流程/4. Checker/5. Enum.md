### 入口

```c++
bool CheckerPhase::Perform(public_lib::Context *ctx, [[maybe_unused]] parser::Program *program)
{
    auto checkerResult = ctx->checker->StartChecker(ctx->parserProgram->VarBinder(), *ctx->config->options);
    return checkerResult;
}

bool ETSChecker::StartChecker(varbinder::VarBinder *varbinder, const util::Options &options)
{
    Initialize(varbinder);

    if (options.IsParseOnly()) {
        return false;
    }

    auto *etsBinder = varbinder->AsETSBinder();
    InitializeBuiltins(etsBinder);

    for (auto &entry : etsBinder->DynamicImportVars()) {
        auto &data = entry.second;
        if (data.import->IsPureDynamic()) {
            data.variable->SetTsType(GlobalBuiltinDynamicType(data.import->Language()));
        }
    }

    bool isEvalMode = (debugInfoPlugin_ != nullptr);
    if (UNLIKELY(isEvalMode)) {
        // SUPPRESS_CSA_NEXTLINE(alpha.core.AllocatorETSCheckerHint)
        debugInfoPlugin_->PreCheck();
    }

    CheckProgram(Program(), true);

    if (UNLIKELY(isEvalMode)) {
        // SUPPRESS_CSA_NEXTLINE(alpha.core.AllocatorETSCheckerHint)
        debugInfoPlugin_->PostCheck();
    }

    // SUPPRESS_CSA_NEXTLINE(alpha.core.AllocatorETSCheckerHint)
    BuildDynamicImportClass();

    if (options.IsDumpDynamicAst()) {
        std::cout << Program()->Dump() << std::endl;
    }

    CheckWarnings(Program(), options);

    return !IsAnyError();
}
```

<img src="assets/微信截图_20250331011548.png" width="50%" height="50%"/>

### AstNode

- AstNode 层，每个节点都有 check 函数，通过函数重载，区分 ETSChecker 还是 TSChecker

```c++
checker::VerifiedType BlockStatement::Check([[maybe_unused]] checker::ETSChecker *checker)
{
    return {this, checker->GetAnalyzer()->Check(this)};
}
checker::Type *BlockStatement::Check([[maybe_unused]] checker::TSChecker *checker)
{
    return checker->GetAnalyzer()->Check(this);
}
```

### ETSAnalyzer

- 每个 AstNode 节点都对应 check 函数，其中一个功能是调用其子节点的 Check 函数

```c++
checker::Type *ETSAnalyzer::Check(ir::ClassDeclaration *st) const
{
  ETSChecker *checker = GetETSChecker();
  st->Definition()->Check(checker);
  return ReturnTypeForStatement(st);
}
```

### Perform

```c++
bool CheckerPhase::Perform(public_lib::Context *ctx, [[maybe_unused]] parser::Program *program)
{
    auto checkerResult = ctx->checker->StartChecker(ctx->parserProgram->VarBinder(), *ctx->config->options);
    return checkerResult;
}

bool ETSChecker::StartChecker(varbinder::VarBinder *varbinder, const util::Options &options)
{
    Initialize(varbinder);

    if (options.IsParseOnly()) {
        return false;
    }

    auto *etsBinder = varbinder->AsETSBinder();
    InitializeBuiltins(etsBinder);

    for (auto &entry : etsBinder->DynamicImportVars()) {
        auto &data = entry.second;
        if (data.import->IsPureDynamic()) {
            data.variable->SetTsType(GlobalBuiltinDynamicType(data.import->Language()));
        }
    }

    bool isEvalMode = (debugInfoPlugin_ != nullptr);
    if (UNLIKELY(isEvalMode)) {
        // SUPPRESS_CSA_NEXTLINE(alpha.core.AllocatorETSCheckerHint)
        debugInfoPlugin_->PreCheck();
    }

    CheckProgram(Program(), true);

    if (UNLIKELY(isEvalMode)) {
        // SUPPRESS_CSA_NEXTLINE(alpha.core.AllocatorETSCheckerHint)
        debugInfoPlugin_->PostCheck();
    }

    // SUPPRESS_CSA_NEXTLINE(alpha.core.AllocatorETSCheckerHint)
    BuildDynamicImportClass();

    if (options.IsDumpDynamicAst()) {
        std::cout << Program()->Dump() << std::endl;
    }

    CheckWarnings(Program(), options);

    return !IsAnyError();
}
```

## CheckProgram

```c++
void ETSChecker::CheckProgram(parser::Program *program, bool runAnalysis)
{
    auto *savedProgram = Program();
    SetProgram(program);

    ......
    Program()->Ast()->Check(this);

    if (runAnalysis && !IsAnyError()) {
        AliveAnalyzer aliveAnalyzer(Program()->Ast(), this);
        AssignAnalyzer(this).Analyze(Program()->Ast());
    }

    ES2PANDA_ASSERT(VarBinder()->AsETSBinder()->GetExternalRecordTable().find(program)->second);

    SetProgram(savedProgram);
}
```

```c++
checker::VerifiedType BlockStatement::Check([[maybe_unused]] checker::ETSChecker *checker)
{
    return {this, checker->GetAnalyzer()->Check(this)};
}
```

```c++
checker::Type *ETSAnalyzer::Check(ir::BlockStatement *st) const
{
    ETSChecker *checker = GetETSChecker();
    checker::ScopeContext scopeCtx(checker, st->Scope());

    // Iterator type checking of statements is modified to index type, to allow modifying the statement list during
    // checking without invalidating the iterator
    //---- Don't modify this to iterator, as it may break things during checking
    for (std::size_t idx = 0; idx < st->Statements().size(); ++idx) {
        auto *stmt = st->Statements()[idx];
        stmt->Check(checker);

        //  NOTE! Processing of trailing blocks was moved here so that smart casts could be applied correctly
        if (auto const tb = st->trailingBlocks_.find(stmt); tb != st->trailingBlocks_.end()) {
            auto *const trailingBlock = tb->second;
            trailingBlock->Check(checker);
            st->Statements().emplace(std::next(st->Statements().begin() + idx), trailingBlock);
            ++idx;
        }
    }
    if (UNLIKELY(checker->GetDebugInfoPlugin() != nullptr)) {
        // Compilation in eval-mode might require to create additional statements.
        // In this case, they must be created after iteration through statements ends.
        checker->GetDebugInfoPlugin()->AddPrologueEpilogue(st);
    }

    auto const *const scope = st->Scope();
    if (scope == nullptr) {
        return ReturnTypeForStatement(st);
    }

    //  Remove possible smart casts for variables declared in inner scope:
    if (scope->IsFunctionScope() && st->Parent()->Parent()->Parent()->IsMethodDefinition()) {
        // When exiting method definition, just clear all smart casts
        checker->Context().ClearSmartCasts();
    } else if (!scope->IsGlobalScope()) {
        // otherwise only check inner declarations
        for (auto const *const decl : scope->Decls()) {
            if (decl->IsLetOrConstDecl() && decl->Node() != nullptr && decl->Node()->IsIdentifier()) {
                checker->Context().RemoveSmartCast(decl->Node()->AsIdentifier()->Variable());
            }
        }
    }

    return ReturnTypeForStatement(st);
}
```

```c++
checker::Type *ETSAnalyzer::Check(ir::ClassDeclaration *st) const
{
  ETSChecker \*checker = GetETSChecker();
  st->Definition()->Check(checker);
  return ReturnTypeForStatement(st);
}
checker::Type *ETSAnalyzer::Check(ir::ClassDefinition *node) const
{
    ETSChecker *checker = GetETSChecker();

    if (node->TsType() == nullptr) {
        checker->BuildBasicClassProperties(node);
    }

    if (!node->IsClassDefinitionChecked()) {
        checker->CheckClassDefinition(node);
    }

    return node->TsType();
}
Type *ETSChecker::BuildBasicClassProperties(ir::ClassDefinition *classDef)
{
    if (classDef->IsFinal() && classDef->IsAbstract()) {
        LogError(diagnostic::ABSTRACT_IS_FINAL, {}, classDef->Start());
    }

    auto *var = classDef->Ident()->Variable();
    if (var == nullptr) {
        ES2PANDA_ASSERT(IsAnyError());
        return GlobalTypeError();
    }

    checker::ETSObjectType *classType {};
    if (var->TsType() == nullptr) {
        classType = CreateETSObjectTypeOrBuiltin(classDef, checker::ETSObjectFlags::CLASS);
        classType->SetVariable(var);
        var->SetTsType(classType);
        if (classDef->IsAbstract()) {
            classType->AddObjectFlag(checker::ETSObjectFlags::ABSTRACT);
        }
    } else {
        classType = var->TsType()->AsETSObjectType();
    }

    classDef->SetTsType(classType);

    ConstraintCheckScope ctScope(this);
    if (classDef->TypeParams() != nullptr) {
        classType->AddTypeFlag(TypeFlag::GENERIC);
        CreateTypeForClassOrInterfaceTypeParameters(classType);
    }

    auto *enclosingClass = Context().ContainingClass();
    classType->SetEnclosingType(enclosingClass);
    CheckerStatus newStatus = CheckerStatus::IN_CLASS;

    if (classDef->IsInner()) {
        newStatus |= CheckerStatus::INNER_CLASS;
        classType->AddObjectFlag(checker::ETSObjectFlags::INNER);
    }

    auto savedContext = checker::SavedCheckerContext(this, newStatus, classType);

    if (!classType->HasObjectFlag(ETSObjectFlags::RESOLVED_SUPER)) {
        GetSuperType(classType);
        GetInterfaces(classType);
    }
    ctScope.TryCheckConstraints();
    return classType;
}
void ETSChecker::CheckClassDefinition(ir::ClassDefinition *classDef)
{
    classDef->SetClassDefinitionChecked();

    if (classDef->TsType() == nullptr) {
        ES2PANDA_ASSERT(IsAnyError());
        classDef->SetTsType(GlobalTypeError());
    }

    if (classDef->TsType()->IsTypeError()) {
        return;
    }

    auto *classType = classDef->TsType()->AsETSObjectType();
    if (classType->SuperType() != nullptr) {
        classType->SuperType()->GetDeclNode()->Check(this);
    }

    auto newStatus = checker::CheckerStatus::IN_CLASS;
    if (Context().ContainingClass() != classType) {
        classType->SetEnclosingType(Context().ContainingClass());
    }

    if (classDef->IsInner()) {
        newStatus |= CheckerStatus::INNER_CLASS;
        classType->AddObjectFlag(checker::ETSObjectFlags::INNER);
    }

    classDef->IsModule() ? classType->AddObjectFlag(checker::ETSObjectFlags::GLOBAL)
                         : CheckLocalClass(classDef, newStatus);

    checker::ScopeContext scopeCtx(this, classDef->Scope());
    auto savedContext = SavedCheckerContext(this, newStatus, classType);

    ResolveDeclaredMembersOfObject(classType);

    if (classDef->IsAbstract()) {
        AddStatus(checker::CheckerStatus::IN_ABSTRACT);
        classType->AddObjectFlag(checker::ETSObjectFlags::ABSTRACT);
    }

    if (classDef->IsStatic() && !Context().ContainingClass()->HasObjectFlag(ETSObjectFlags::GLOBAL)) {
        AddStatus(checker::CheckerStatus::IN_STATIC_CONTEXT);
    }

    // NOTE(gogabr): temporary, until we have proper bridges, see #16485
    // Don't check overriding for synthetic functional classes.
    if ((static_cast<ir::AstNode *>(classDef)->Modifiers() & ir::ModifierFlags::FUNCTIONAL) == 0) {
        ValidateOverriding(classType, classDef->Start());
    }
    // SUPPRESS_CSA_NEXTLINE(alpha.core.AllocatorETSCheckerHint)
    TransformProperties(classType);
    CheckClassElement(classDef);

    if (classDef->IsGlobal() || classType->SuperType() == nullptr) {
        return;
    }

    CheckClassAnnotations(classDef);
    CheckConstructors(classDef, classType);
    CheckValidInheritance(classType, classDef);
    CheckConstFields(classType);
    CheckGetterSetterProperties(classType);
    CheckInvokeMethodsLegitimacy(classType);
    CheckTypeParameterVariance(classDef);
}
```
