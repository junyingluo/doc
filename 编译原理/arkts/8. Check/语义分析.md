## 关系

- AstNode
  - Statement
    - ClassDeclaration
    - BlockStatement
    - AnnotationAllowed<AstNode>
      - ScriptFunction
    - Typed<Statement>
      - TypedStatement
        - ClassElement
          - MethodDefinition
            - Expression \*key\_;
            - Expression \*value\_;
- SemanticAnalyzer
  - ETSAnalyzer
    - GetETSChecker() 获取 ETSChecker
    - ETSAnalyzer::Check(ir::BlockStatement \*st) 分析 AstNode 的类型
- checker
  - ETSChecker
    - GetAnalyzer() 获取 ETSAnalyzer

## 入口

- Program()->Ast() 返回 BlockStatement

```c++
void ETSChecker::CheckProgram(parser::Program *program, bool runAnalysis)
{
    ......
    Program()->Ast()->Check(this); // 入口
    ......
}
```

## 获取 BlockStatement 类型

```c++
checker::VerifiedType BlockStatement::Check([[maybe_unused]] checker::ETSChecker *checker)
{
    return {this, checker->GetAnalyzer()->Check(this)};
}
checker::Type *ETSAnalyzer::Check(ir::BlockStatement *st) const
{
    ETSChecker *checker = GetETSChecker();
    checker::ScopeContext scopeCtx(checker, st->Scope());

    for (std::size_t idx = 0; idx < st->Statements().size(); ++idx) {
        auto *stmt = st->Statements()[idx];
        stmt->Check(checker); // 入口
        ......
    }
    ......
}
```

## 获取 ClassDeclaration 类型

```c++
checker::VerifiedType ClassDeclaration::Check(checker::ETSChecker *checker)
{
    return {this, checker->GetAnalyzer()->Check(this)};
}
checker::Type *ETSAnalyzer::Check(ir::ClassDeclaration *st) const
{
    ETSChecker *checker = GetETSChecker();
    st->Definition()->Check(checker);
    return ReturnTypeForStatement(st);
}
```

## 获取 ClassDefinition 类型

```c++
checker::VerifiedType ClassDefinition::Check(checker::ETSChecker *checker)
{
    return {this, checker->GetAnalyzer()->Check(this)};
}
checker::Type *ETSAnalyzer::Check(ir::ClassDefinition *node) const
{
    ETSChecker *checker = GetETSChecker();

    if (node->TsType() == nullptr) {
        checker->BuildBasicClassProperties(node);
    }

    if (!node->IsClassDefinitionChecked()) {
        checker->CheckClassDefinition(node);
    }

    return node->TsType();
}
void ETSChecker::CheckClassDefinition(ir::ClassDefinition *classDef)
{
    ......
    CheckClassElement(classDef);
    ......
}
void ETSChecker::CheckClassElement(ir::ClassDefinition *classDef)
{
    for (auto *it : classDef->Body()) {
        if (it->IsClassProperty()) {
            it->Check(this);
        }
    }

    for (auto *it : classDef->Body()) {
        if (!it->IsClassProperty()) {
            if (it->IsETSModule() && it->AsETSModule()->IsNamespace()) {
                ASSERT(IsAnyError());
                continue;
            }
            it->Check(this);
        }
    }
}
```

## 获取 MethodDefinition 类型

将 MethodDefinition 的 value\_ 转换为 ScriptFunction

```c++
checker::VerifiedType MethodDefinition::Check(checker::ETSChecker *checker)
{
    return {this, checker->GetAnalyzer()->Check(this)};
}

checker::Type *ETSAnalyzer::Check(ir::MethodDefinition *node) const
{
    ETSChecker *checker = GetETSChecker();
    auto *scriptFunc = node->Function();

    // CC-OFFNXT(G.FMT.14-CPP) project code style
    auto const returnErrorType = [checker, node]() -> checker::Type * {
        node->SetTsType(checker->GlobalTypeError());
        return node->TsType();
    };

    if (scriptFunc == nullptr) {
        checker->LogTypeError("Invalid function expression", node->Start());
        return returnErrorType();
    }
    checker->CheckAnnotations(scriptFunc->Annotations());
    // ---------------------------
    checker->CheckFunctionSignatureAnnotations(scriptFunc->Params(), scriptFunc->TypeParams(),
                                               scriptFunc->ReturnTypeAnnotation());

    if (scriptFunc->IsProxy()) {
        return ReturnTypeForStatement(node);
    }

    ASSERT(!(scriptFunc->IsGetter() && scriptFunc->IsSetter()));
    if (scriptFunc->IsGetter() || scriptFunc->IsSetter()) {
        auto status = scriptFunc->IsGetter() ? CheckerStatus::IN_GETTER : CheckerStatus::IN_SETTER;
        checker->AddStatus(status);
    }

    // NOTE: aszilagyi. make it correctly check for open function not have body
    if (!scriptFunc->HasBody() && !(node->IsAbstract() || node->IsNative() || node->IsDeclare() ||
                                    checker->HasStatus(checker::CheckerStatus::IN_INTERFACE))) {
        checker->LogTypeError("Only abstract or native methods can't have body.", scriptFunc->Start());
        return returnErrorType();
    }

    if (scriptFunc->ReturnTypeAnnotation() == nullptr &&
        ((node->IsNative() || node->IsDeclare()) && !node->IsConstructor())) {
        checker->LogTypeError("Native and Declare methods should have explicit return type.", scriptFunc->Start());
        return returnErrorType();
    }

    if (node->TsType() == nullptr) {
        node->SetTsType(checker->BuildMethodSignature(node));
    }

    this->CheckMethodModifiers(node);
    HandleNativeAndAsyncMethods(checker, node);
    // -----------------------
    DoBodyTypeChecking(checker, node, scriptFunc);
    CheckPredefinedMethodReturnType(checker, scriptFunc);
    if (node->TsType()->IsTypeError()) {
        return node->TsType();
    }

    return CheckMethodDefinitionHelper(checker, node);
}
void DoBodyTypeChecking(ETSChecker *checker, ir::MethodDefinition *node, ir::ScriptFunction *scriptFunc)
{
    if (scriptFunc->HasBody()) {
        CheckMethodBodyForNativeAbstractDeclare(checker, node, scriptFunc);
        CheckNativeConstructorBody(checker, node, scriptFunc);
    }

    if (!scriptFunc->IsAsyncFunc() && scriptFunc->HasBody() &&
        (!scriptFunc->IsExternal() || scriptFunc->IsExternalOverload())) {
        checker::ScopeContext scopeCtx(checker, scriptFunc->Scope());
        checker::SavedCheckerContext savedContext(checker, checker->Context().Status(),
                                                  checker->Context().ContainingClass());
        // ------------------------
        checker->Context().SetContainingSignature(checker->GetSignatureFromMethodDefinition(node));

        if (node->IsStatic() && !node->IsConstructor() &&
            !checker->Context().ContainingClass()->HasObjectFlag(checker::ETSObjectFlags::GLOBAL)) {
            checker->AddStatus(checker::CheckerStatus::IN_STATIC_CONTEXT);
        }

        if (node->IsConstructor()) {
            checker->AddStatus(checker::CheckerStatus::IN_CONSTRUCTOR);
        }

        if (node->IsExtensionMethod()) {
            CheckExtensionMethod(checker, scriptFunc, node);
        }

        // ---------------------
        scriptFunc->Body()->Check(checker);

        if (scriptFunc->ReturnTypeAnnotation() == nullptr) {
            if (scriptFunc->IsAsyncImplFunc()) {
                ComposeAsyncImplFuncReturnType(checker, scriptFunc);
            }

            for (auto &returnStatement : scriptFunc->ReturnStatements()) {
                returnStatement->SetReturnType(checker, scriptFunc->Signature()->ReturnType());
            }
        }

        checker->Context().SetContainingSignature(nullptr);
    }
}
```

```c++
checker::VerifiedType BlockStatement::Check([[maybe_unused]] checker::ETSChecker *checker)
{
    return {this, checker->GetAnalyzer()->Check(this)};
}
checker::Type *ETSAnalyzer::Check(ir::BlockStatement *st) const
{
    ETSChecker *checker = GetETSChecker();
    checker::ScopeContext scopeCtx(checker, st->Scope());

    for (std::size_t idx = 0; idx < st->Statements().size(); ++idx) {
        auto *stmt = st->Statements()[idx];
        stmt->Check(checker); // 入口
        ......
    }
    ......
}
```

## 计算返回值类型

containingFunc 指向目标函数

```c++
checker::VerifiedType ReturnStatement::Check(checker::ETSChecker *checker)
{
    return {this, checker->GetAnalyzer()->Check(this)};
}
checker::Type *ETSAnalyzer::Check(ir::ReturnStatement *st) const
{
    ETSChecker *checker = GetETSChecker();

    ir::AstNode *ancestor = util::Helpers::FindAncestorGivenByType(st, ir::AstNodeType::SCRIPT_FUNCTION);
    ASSERT(ancestor && ancestor->IsScriptFunction());

    auto *containingFunc = ancestor->AsScriptFunction();
    if (containingFunc->Signature() == nullptr) {
        ASSERT(checker->IsAnyError());
        return ReturnTypeForStatement(st);
    }

    checker->AddStatus(CheckerStatus::MEET_RETURN);

    if (containingFunc->IsConstructor()) {
        if (st->argument_ != nullptr) {
            checker->LogTypeError("Return statement with expression isn't allowed in constructor.", st->Start());
            return checker->GlobalTypeError();
        }
        return ReturnTypeForStatement(st);
    }

    // -------------
    st->returnType_ = GetFunctionReturnType(st, containingFunc);

    if (containingFunc->ReturnTypeAnnotation() == nullptr) {
        containingFunc->AddReturnStatement(st);
    }

    return ReturnTypeForStatement(st);
}
checker::Type *ETSAnalyzer::GetFunctionReturnType(ir::ReturnStatement *st, ir::ScriptFunction *containingFunc) const
{
    ASSERT(containingFunc->ReturnTypeAnnotation() != nullptr || containingFunc->Signature()->ReturnType() != nullptr);

    ETSChecker *checker = GetETSChecker();
    checker::Type *funcReturnType = nullptr;

    if (auto *const returnTypeAnnotation = containingFunc->ReturnTypeAnnotation(); returnTypeAnnotation != nullptr) {
        // --------------
        if (!CheckInferredFunctionReturnType(st, containingFunc, funcReturnType, returnTypeAnnotation, checker)) {
            return checker->GlobalTypeError();
        }
    } else {
        ......
    }

    if ((st->argument_ != nullptr) && st->argument_->IsArrayExpression() && funcReturnType->IsArrayType()) {
        checker->ModifyPreferredType(st->argument_->AsArrayExpression(), funcReturnType);
        st->argument_->Check(checker);
    }

    return funcReturnType;
}
bool ETSAnalyzer::CheckInferredFunctionReturnType(ir::ReturnStatement *st, ir::ScriptFunction *containingFunc,
                                                  checker::Type *&funcReturnType, ir::TypeNode *returnTypeAnnotation,
                                                  ETSChecker *checker) const
{
    if (!CheckIsValidReturnTypeAnnotation(st, containingFunc, returnTypeAnnotation, checker)) {
        return false;
    }

    funcReturnType = containingFunc->ReturnTypeAnnotation()->GetType(checker);

    // Case when function's return type is defined explicitly:
    if (st->argument_ == nullptr) {
        ......
    } else {
        const auto name = containingFunc->Scope()->InternalName().Mutf8();
        if (!CheckArgumentVoidType(funcReturnType, checker, name, st)) {
            return false;
        }

        if (st->argument_->IsObjectExpression()) {
            st->argument_->AsObjectExpression()->SetPreferredType(funcReturnType);
        }
        if (st->argument_->IsMemberExpression()) {
            checker->SetArrayPreferredTypeForNestedMemberExpressions(st->argument_->AsMemberExpression(),
                                                                     funcReturnType);
        }

        if (st->argument_->IsArrayExpression()) {
            st->argument_->AsArrayExpression()->SetPreferredType(funcReturnType);
        }
        // -------------
        checker::Type *argumentType = st->argument_->Check(checker);
        return CheckReturnType(checker, funcReturnType, argumentType, st->argument_, containingFunc);
    }
    return true;
}
```

```
checker::VerifiedType BinaryExpression::Check(checker::ETSChecker *checker)
{
return {this, checker->GetAnalyzer()->Check(this)};
}
checker::Type *ETSAnalyzer::Check(ir::BinaryExpression \*expr) const
{
if (expr->TsType() != nullptr) {
return expr->TsType();
}

    ETSChecker *checker = GetETSChecker();
    checker::Type *newTsType {nullptr};
    std::tie(newTsType, expr->operationType_) =
        checker->CheckBinaryOperator(expr->Left(), expr->Right(), expr, expr->OperatorType(), expr->Start());
    expr->SetTsType(newTsType);

    checker->Context().CheckBinarySmartCastCondition(expr);

    return expr->TsType();

}
std::tuple<Type _, Type _> ETSChecker::CheckBinaryOperator(ir::Expression *left, ir::Expression *right,
ir::Expression *expr, lexer::TokenType operationType,
lexer::SourcePosition pos, bool forcePromotion)
{
checker::Type *leftType = TryGetTypeFromExtensionAccessor(left);

    if (leftType == nullptr) {
        LogTypeError("Unexpected type error in binary expression", left->Start());
        auto rightType = right->Check(this);
        return {rightType, rightType};
    }

    if (operationType == lexer::TokenType::KEYW_INSTANCEOF) {
        AddStatus(checker::CheckerStatus::IN_INSTANCEOF_CONTEXT);
    }

    Context().CheckTestSmartCastCondition(operationType);
    checker::Type *rightType = TryGetTypeFromExtensionAccessor(right);

    if (rightType == nullptr) {
        rightType = right->Check(this);
    }

    if (right->IsTypeNode()) {
        rightType = right->AsTypeNode()->GetType(this);
    }

    if (rightType == nullptr) {
        LogTypeError("Unexpected type error in binary expression", pos);
        return {leftType, leftType};
    }

    CheckNeedToGenerateGetValueForBinaryExpression(expr);

    const bool isLogicalExtendedOperator = (operationType == lexer::TokenType::PUNCTUATOR_LOGICAL_AND) ||
                                           (operationType == lexer::TokenType::PUNCTUATOR_LOGICAL_OR);
    Type *unboxedL =
        isLogicalExtendedOperator ? MaybeUnboxConditionalInRelation(leftType) : MaybeUnboxInRelation(leftType);
    Type *unboxedR =
        isLogicalExtendedOperator ? MaybeUnboxConditionalInRelation(rightType) : MaybeUnboxInRelation(rightType);

    bool isEqualOp = (operationType > lexer::TokenType::PUNCTUATOR_SUBSTITUTION &&
                      operationType < lexer::TokenType::PUNCTUATOR_ARROW) &&
                     !forcePromotion;

    if (CheckBinaryOperatorForBigInt(leftType, rightType, operationType)) {
        return ResolveCheckBinaryOperatorForBigInt(this, leftType, rightType, operationType);
    }

    // --------------
    return CheckArithmeticOperations(expr, std::make_tuple(left, right, operationType, pos), isEqualOp,
                                     std::make_tuple(leftType, rightType, unboxedL, unboxedR));

}
```
