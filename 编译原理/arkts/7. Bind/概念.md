## varbinder

- scope\_ 当前作用域
- topScope\_ 根作用域
- varScope\_

```c++
void VarBinder::InitTopScope()
{
    if (program_->Kind() == parser::ScriptKind::MODULE) {
        topScope_ = Allocator()->New<ModuleScope>(Allocator());
    } else {
        topScope_ = Allocator()->New<GlobalScope>(Allocator());
    }

    scope_ = topScope_;
    varScope_ = topScope_;
}
```

## LexicalScope

工具类，用于创建对应 Scope，例如

varbinder::LexicalScope<varbinder::Scope>::Enter(varBinder, scope);

```c++
class LexicalScope {
public:
    template <typename... Args>
    explicit LexicalScope(VarBinder *varbinder, Args &&...args)
        : LexicalScope(
              varbinder->Allocator()->New<T>(varbinder->Allocator(), varbinder->scope_, std::forward<Args>(args)...),
              varbinder)
    {
    }

    T *GetScope() const
    {
        return scope_;
    }

    ~LexicalScope()
    {
        ES2PANDA_ASSERT(varbinder_);
        varbinder_->scope_ = prevScope_;
        varbinder_->varScope_ = prevVarScope_;
    }

    [[nodiscard]] static LexicalScope<T> Enter(VarBinder *varbinder, T *scope, bool checkEval = true)
    {
        LexicalScope<T> lexScope(scope, varbinder);
        if (!checkEval || varbinder->Extension() == ScriptExtension::TS) {
            return lexScope;
        }

        // NOLINTNEXTLINE(readability-braces-around-statements)
        if constexpr (std::is_same_v<T, FunctionParamScope>) {
            varbinder->varScope_ = scope->GetFunctionScope();
            varbinder->varScope_->CheckDirectEval(varbinder->context_);
            // NOLINTNEXTLINE(readability-braces-around-statements,readability-misleading-indentation)
        } else if constexpr (std::is_same_v<T, FunctionScope>) {
            varbinder->varScope_ = scope;
            varbinder->varScope_->CheckDirectEval(varbinder->context_);
            // NOLINTNEXTLINE(readability-braces-around-statements,readability-misleading-indentation)
        } else if constexpr (std::is_same_v<T, LoopScope>) {
            if (scope->IsLoopScope()) {
                varbinder->varScope_ = scope;
                varbinder->varScope_->CheckDirectEval(varbinder->context_);
            }
            // NOLINTNEXTLINE(readability-braces-around-statements,readability-misleading-indentation)
        } else if constexpr (std::is_same_v<T, LoopDeclarationScope>) {
            if (scope->IsLoopDeclarationScope()) {
                varbinder->varScope_ = scope;
                varbinder->varScope_->CheckDirectEval(varbinder->context_);
            }
        }

        return lexScope;
    }

    DEFAULT_MOVE_SEMANTIC(LexicalScope);

private:
    NO_COPY_SEMANTIC(LexicalScope);

    explicit LexicalScope(T *scope, VarBinder *varbinder)
        : varbinder_(varbinder), scope_(scope), prevScope_(varbinder->scope_), prevVarScope_(varbinder->varScope_)
    {
        varbinder_->scope_ = scope_;
    }

    VarBinder *varbinder_ {};
    T *scope_ {};
    Scope *prevScope_ {};
    VariableScope *prevVarScope_ {};
};
```

## 总体

- Decl 表示变量类型
- Variable 表示变量
  - decl\_
- Scope 表示作用域，其包含所有该作用域下变量
  - ArenaVector<Decl \*> decls\_
  - VariableMap bindings\_ 存储变量名和 Variable 的映射关系

## Identifier

- NewVarDecl 将 Identifier 转换为 Variable，保存到 bindings\_中
  - program->VarBinder()->NewVarDecl<varbinder::ClassDecl>(globalId->Start(), globalId->Name());

## 类关系

- Variable

  - LocalVariable
  - GlobalVariable
  - ModuleVariable
  - EnumVariable

- Decl

  - LetDecl
  - ConstDecl
  - ClassDecl

- Scope
  - LocalScope
  - VariableScope
    - ScopeWithParamScope<VariableScope, FunctionParamScope>
      - FunctionScope
        - GlobalScope
          - ModuleScope

## Scope
