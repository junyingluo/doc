- 概要

加载内置库

- Perform

  ```c++
  bool TopLevelStatements::Perform(public_lib::Context *ctx, parser::Program *program)
  {
      auto imports = ImportExportDecls(program->VarBinder()->AsETSBinder(), ctx->parser->AsETSParser());
      imports.ParseDefaultSources();

      GlobalClassHandler globalClass(ctx->parser->AsETSParser(), program->Allocator());
      for (auto &[package, extPrograms] : program->ExternalSources()) {
          auto moduleDependencies = imports.HandleGlobalStmts(extPrograms);
          globalClass.SetupGlobalClass(extPrograms, &moduleDependencies);
      }

      ArenaVector<parser::Program *> mainModule(program->Allocator()->Adapter());
      mainModule.emplace_back(program);
      auto moduleDependencies = imports.HandleGlobalStmts(mainModule);
      globalClass.SetupGlobalClass(mainModule, &moduleDependencies);
      return true;
  }
  ```

* ImportExportDecls

  - 将内置库转换为代码
    - 将 std/core 转换为 import \* from "std/core"

  ```c++
  const std::string defaultImportSource_ = CreateDefaultImportSource(util::Helpers::StdLib());

  std::vector<std::string> const &Helpers::StdLib()
  {
      static std::vector<std::string> stdlib {
        "std/core", "std/math", "std/containers", "std/time", "std/interop/js",
        "std/debug", "std/debug/concurrency", "std/testing", "escompat", "std/concurrency",
        "std/annotations"};
      return stdlib;
  }

  static std::string CreateDefaultImportSource(const std::vector<std::string> &paths)
  {
      std::string importStdlibFile;
      for (const auto &path : paths) {
          importStdlibFile += "import * from \"" + path + "\";";
      }
      return importStdlibFile;
  }
  ```

* ParseDefaultSources

  - 初始化 Lexer

    - 调用 ParseImportDeclarations 解析

  ```c++
  ArenaVector<ir::ETSImportDeclaration *> ETSParser::ParseDefaultSources(std::string_view srcFile,
                                                                       std::string_view importSrc)
  {
      auto isp = InnerSourceParser(this);
      SourceFile source(srcFile, importSrc);

      auto lexer = InitLexer(source);

      Lexer()->NextToken();

      GetContext().Status() |= ParserStatus::IN_DEFAULT_IMPORTS;
      auto statements = ParseImportDeclarations();
      GetContext().Status() &= ~ParserStatus::IN_DEFAULT_IMPORTS;

      AddExternalSource(ParseSources());
      return statements;
  }
  ```

  - ParseSources

    - 解析外部文件，并生成 programs

  - AddExternalSource
    - 将 ParseSources 解析生成的 programs 添加到 extSources[name] 中

  ```c++
  void ETSParser::AddExternalSource(const std::vector<Program *> &programs)
  {
      auto &extSources = globalProgram_->ExternalSources();

      for (auto *newProg : programs) {
          const util::StringView name = newProg->ModuleName();
          if (extSources.count(name) == 0) {
              extSources.try_emplace(name, Allocator()->Adapter());
          }

          extSources.at(name).emplace_back(newProg);
      }
  }
  ```
